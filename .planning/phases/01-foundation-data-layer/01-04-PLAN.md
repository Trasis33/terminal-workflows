---
phase: 01-foundation-data-layer
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - internal/store/yaml_test.go
  - internal/template/template_test.go
  - cmd/wf/cli_test.go
autonomous: true

must_haves:
  truths:
    - "Full CLI flow works end-to-end: add → edit → rm"
    - "Multiline commands survive the full create-read-update-delete cycle"
    - "Workflows in nested folders (max 2 levels) are listed and accessible"
    - "All edge cases pass: Norway Problem, nested quotes, empty fields, special characters"
  artifacts:
    - path: "cmd/wf/cli_test.go"
      provides: "End-to-end CLI integration tests"
      min_lines: 60
  key_links:
    - from: "cmd/wf/cli_test.go"
      to: "internal/store/yaml.go"
      via: "tests full CRUD cycle through CLI layer"
      pattern: "store\\.NewYAMLStore|YAMLStore"
    - from: "cmd/wf/cli_test.go"
      to: "cmd/wf/root.go"
      via: "executes Cobra commands programmatically"
      pattern: "rootCmd\\.Execute|SetArgs"
---

<objective>
Add end-to-end integration tests that exercise the full CLI → store → template pipeline, ensuring all Phase 1 success criteria are verifiable.

Purpose: Unit tests (Plans 01/02) verify components in isolation. This plan verifies the wiring — that CLI commands correctly call the store, that the store correctly uses YAML, and that the template engine integrates properly. These tests are the proof that Phase 1 success criteria are met.

Output: Integration test suite covering full CRUD flow, multiline commands, folder organization, and edge cases.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-layer/01-CONTEXT.md
@.planning/phases/01-foundation-data-layer/01-01-SUMMARY.md
@.planning/phases/01-foundation-data-layer/01-02-SUMMARY.md
@.planning/phases/01-foundation-data-layer/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: End-to-end CLI integration tests</name>
  <files>
    cmd/wf/cli_test.go
  </files>
  <action>
    Create integration tests that exercise the full pipeline:

    1. Create `cmd/wf/cli_test.go`:
       - Use `t.TempDir()` as the workflow base path (not real ~/.config/wf/)
       - Create a helper that constructs a Cobra root command wired to a YAMLStore pointed at the temp dir
       - Execute commands programmatically via `rootCmd.SetArgs([]string{...})` + `rootCmd.Execute()`

    2. Test cases (at minimum):

       **Full CRUD cycle:**
       - Add a workflow via flags → verify YAML file exists and has correct content
       - Edit the workflow via `--description` flag → verify file updated
       - Delete the workflow via `--force` → verify file removed

       **Multiline command:**
       - Add workflow with command containing newlines (via store.Save directly, since CLI flag can't have literal newlines)
       - Read it back, verify newlines preserved
       - This validates STOR-04

       **Parameterized workflow:**
       - Add workflow with command `"ssh {{host:localhost}} -p {{port:22}}"`
       - Verify the saved YAML file has args section with host (default: localhost) and port (default: 22)
       - This validates PARM-01, PARM-02

       **Duplicate parameter name:**
       - Add workflow with command `"echo {{msg}} && echo {{msg}}"`
       - Verify args has only ONE entry for "msg"
       - Use template.Render with {"msg": "hello"} and verify both occurrences replaced
       - This validates PARM-05

       **Folder organization:**
       - Save a workflow with folder path `infra/deploy`
       - Verify file exists at `tempdir/infra/deploy.yaml`
       - List workflows, verify it appears
       - This validates ORGN-02

       **Tags:**
       - Add workflow with multiple tags
       - Verify tags in YAML file
       - Edit workflow to add/remove tags
       - This validates ORGN-01

       **Norway Problem (regression):**
       - Save workflow with command containing "no", "yes", "off", "on"
       - Read back, verify strings not corrupted to booleans
       - Test with commands like: `redis-cli CONFIG SET appendonly no`
       - This is a critical regression test

       **Nested quotes:**
       - Save workflow with command: `docker exec -it mydb psql -c "SELECT * FROM users WHERE name = 'test'"`
       - Read back, verify quotes preserved

    3. Optional: extend `internal/store/yaml_test.go` with any additional edge cases discovered during integration testing

    All tests should use `assert` / `require` from testify for readable assertions.
  </action>
  <verify>
    `go test ./... -v` — ALL tests pass (unit + integration).
    `go test ./... -count=1 -race` — no race conditions.
    `go vet ./...` — clean.
  </verify>
  <done>
    Full test suite passes. CRUD cycle works end-to-end. Multiline commands, parameterized workflows, duplicate params, folder organization, tags, Norway Problem, and nested quotes all verified by tests. All Phase 1 success criteria are testable and passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Final verification and cleanup</name>
  <files>
    cmd/wf/root.go
  </files>
  <action>
    Final polish and verification:

    1. Ensure all commands have consistent error handling:
       - Non-existent workflow → clear error message with workflow name
       - Invalid YAML after editor edit → error with hint
       - Permission denied → clear error
       - All errors go to stderr, success messages to stdout

    2. Add a `wf list` command (simple, needed for basic usability):
       - Lists all workflows with format: `name  description  [tags]`
       - One line per workflow
       - Supports `--folder` flag to list from specific subfolder
       - This is a natural complement to add/edit/rm and validates store.List() works end-to-end

    3. Verify the complete help tree:
       - `wf --help` shows all subcommands
       - `wf add --help`, `wf edit --help`, `wf rm --help`, `wf list --help` all work
       - Help text is concise and useful

    4. Run full test suite: `go test ./... -v -race`
    5. Run linting: `go vet ./...`
    6. Verify clean build: `go build -o wf ./cmd/wf/`
  </action>
  <verify>
    `go build -o wf ./cmd/wf/` produces binary.
    `./wf --help` shows add, edit, rm, list subcommands.
    `go test ./... -v -race` passes with zero failures.
    `go vet ./...` clean.
    Manual smoke test:
      `./wf add --name demo --command "echo {{name}}" --tag test`
      `./wf list` shows demo workflow
      `./wf rm demo --force`
      `./wf list` shows no workflows
  </verify>
  <done>
    All CLI commands work. Help text is complete. Error handling is consistent. Test suite passes with race detector. Binary builds cleanly. Phase 1 is feature-complete.
  </done>
</task>

</tasks>

<verification>
1. `go test ./... -v -race` — zero failures, no races
2. `go vet ./...` — clean
3. `go build -o wf ./cmd/wf/` — produces working binary
4. Manual CRUD smoke test passes
5. All 10 Phase 1 requirements verified:
   - STOR-01: wf add creates workflow ✓
   - STOR-02: wf edit modifies workflow ✓
   - STOR-03: wf rm deletes workflow ✓
   - STOR-04: multiline commands preserved ✓
   - STOR-06: YAML files in ~/.config/wf/ ✓
   - PARM-01: {{named}} parameters parsed ✓
   - PARM-02: default values extracted ✓
   - PARM-05: duplicate params deduplicated ✓
   - ORGN-01: tags assigned ✓
   - ORGN-02: folder organization works ✓
</verification>

<success_criteria>
- Complete test suite passes with race detector
- Full CRUD cycle works end-to-end via CLI
- All 10 Phase 1 requirements have at least one test covering them
- Binary builds and runs correctly
- wf list shows stored workflows
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-04-SUMMARY.md`
</output>
