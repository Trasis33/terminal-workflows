---
phase: 01-foundation-data-layer
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - cmd/wf/add.go
  - cmd/wf/edit.go
  - cmd/wf/rm.go
  - cmd/wf/root.go
autonomous: true

must_haves:
  truths:
    - "User can run `wf add --name deploy --command 'kubectl apply -f {{file}}' --description 'Deploy to k8s' --tag k8s --tag deploy` and a YAML file is created"
    - "User can run `wf add` with missing flags and gets interactive prompts for required fields"
    - "User can run `wf edit deploy` and it opens the workflow YAML in $EDITOR"
    - "User can run `wf edit deploy --tag docker` for quick field updates without opening editor"
    - "User can run `wf rm deploy` and gets a confirmation prompt, then the file is deleted"
    - "User can run `wf rm deploy --force` to skip confirmation"
    - "Each command prints minimal one-liner feedback after operation"
  artifacts:
    - path: "cmd/wf/add.go"
      provides: "wf add command with flags + interactive fallback"
      contains: "func addCmd"
    - path: "cmd/wf/edit.go"
      provides: "wf edit command with $EDITOR + flag updates"
      contains: "func editCmd"
    - path: "cmd/wf/rm.go"
      provides: "wf rm command with confirmation + --force"
      contains: "func rmCmd"
  key_links:
    - from: "cmd/wf/add.go"
      to: "internal/store/yaml.go"
      via: "calls store.Save() to persist new workflow"
      pattern: "store\\.Save|Store\\.Save"
    - from: "cmd/wf/add.go"
      to: "internal/template/parser.go"
      via: "calls ExtractParams to auto-discover args from command string"
      pattern: "template\\.ExtractParams|ExtractParams"
    - from: "cmd/wf/edit.go"
      to: "internal/store/yaml.go"
      via: "calls store.Get() then store.Save() for updates"
      pattern: "store\\.(Get|Save)"
    - from: "cmd/wf/rm.go"
      to: "internal/store/yaml.go"
      via: "calls store.Delete() to remove workflow"
      pattern: "store\\.Delete"
    - from: "cmd/wf/root.go"
      to: "cmd/wf/add.go"
      via: "registers add subcommand"
      pattern: "AddCommand|addCmd"
---

<objective>
Implement the three CLI commands (`wf add`, `wf edit`, `wf rm`) that let users create, modify, and delete workflows from the terminal.

Purpose: These commands are the user-facing interface to the data layer built in Plans 01 and 02. They connect Cobra CLI routing to the YAML store and template parser, completing the Phase 1 CRUD loop.

Output: Three working Cobra subcommands with flags, interactive fallback prompts, and $EDITOR integration.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-layer/01-CONTEXT.md
@.planning/phases/01-foundation-data-layer/01-01-SUMMARY.md
@.planning/phases/01-foundation-data-layer/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement `wf add` command</name>
  <files>
    cmd/wf/add.go
    cmd/wf/root.go
  </files>
  <action>
    Create the `wf add` Cobra subcommand:

    1. Create `cmd/wf/add.go`:
       - Cobra command with `Use: "add"`, `Short: "Create a new workflow"`
       - Flags:
         - `--name` / `-n` (string): workflow name (required)
         - `--command` / `-c` (string): command template (required)
         - `--description` / `-d` (string): description (optional)
         - `--tag` / `-t` (string slice): tags, repeatable (optional)
         - `--folder` / `-f` (string): subfolder path under workflows/ (optional, max 2 levels)
       - If `--name` or `--command` flags are missing, prompt interactively:
         - Use `fmt.Print` + `bufio.Scanner` for simple line input prompts (no TUI dependency in Phase 1)
         - Prompt: "Workflow name: " → reads name
         - Prompt: "Command (single line, or enter 'multi' for multiline): " → for multiline, read until blank line
         - Prompt: "Description (optional): " → reads description
         - Prompt: "Tags (comma-separated, optional): " → reads, splits on comma
       - After collecting fields, call `template.ExtractParams(command)` to auto-discover parameters from the command string
       - Populate `Workflow.Args` from extracted params (name + default from inline syntax)
       - Call `store.Save(&workflow)` to write YAML file
       - Print feedback: `fmt.Printf("Created %s\n", workflow.Name)`
       - Handle errors: duplicate name (file exists), invalid folder depth (>2 levels)

    2. Update `cmd/wf/root.go`:
       - Register addCmd as subcommand of rootCmd
       - Initialize YAMLStore with config.WorkflowsDir() and pass to subcommands
       - Use Cobra's `PersistentPreRunE` on root to set up store instance

    NOTE: For interactive multiline input, support a simple protocol: user types "multi" at the command prompt, then enters lines until an empty line signals end. Join with newlines.
  </action>
  <verify>
    `go build ./cmd/wf/` compiles.
    `go run ./cmd/wf/ add --name test-workflow --command "echo hello" --description "A test" --tag test` creates a YAML file in the configured workflows directory.
    The created YAML file contains correct name, command, description, and tags.
    `go run ./cmd/wf/ add --help` shows all flags with descriptions.
  </verify>
  <done>
    `wf add` creates workflow YAML files from flags. Interactive fallback prompts for missing required fields. Template params auto-extracted from command. Feedback printed after creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement `wf edit` and `wf rm` commands</name>
  <files>
    cmd/wf/edit.go
    cmd/wf/rm.go
  </files>
  <action>
    Create `wf edit` and `wf rm` Cobra subcommands:

    **`wf edit` (cmd/wf/edit.go):**
    - Cobra command with `Use: "edit [name]"`, `Short: "Edit a workflow"`
    - Args: exactly 1 positional arg (workflow name)
    - Behavior (two modes):
      a. **Editor mode (default):** If no update flags are provided, open the workflow's YAML file in `$EDITOR` (fall back to `vi` if unset). Use `os/exec` to run the editor, wait for it to exit. After editor closes, re-read the file to validate YAML — if parse fails, print error and ask user to re-edit or abort.
      b. **Quick update mode:** If flags are provided, update specific fields without opening editor:
         - `--command` / `-c` (string): replace command
         - `--description` / `-d` (string): replace description
         - `--tag` / `-t` (string slice): replace tags (overwrites, not appends)
         - `--add-tag` (string): add a single tag to existing list
         - `--remove-tag` (string): remove a single tag from existing list
    - Call `store.Get(name)` to load, modify fields, call `store.Save(workflow)` to persist
    - If command field is updated, re-run `template.ExtractParams()` to refresh args
    - Print feedback: `fmt.Printf("Updated %s\n", name)`
    - Error if workflow doesn't exist

    **`wf rm` (cmd/wf/rm.go):**
    - Cobra command with `Use: "rm [name]"`, `Short: "Delete a workflow"`
    - Args: exactly 1 positional arg (workflow name)
    - `--force` / `-f` flag: skip confirmation prompt
    - Default behavior: print `"Delete workflow 'name'? [y/N]: "` and read input. Only delete on "y" or "yes" (case-insensitive).
    - Call `store.Delete(name)` to remove file
    - Print feedback: `fmt.Printf("Deleted %s\n", name)`
    - Error if workflow doesn't exist

    Register both commands in root.go.

    IMPORTANT for editor integration: The editor should be invoked with the full file path. Use `exec.Command(editor, filePath)` with `cmd.Stdin = os.Stdin`, `cmd.Stdout = os.Stdout`, `cmd.Stderr = os.Stderr` so the editor takes over the terminal properly.
  </action>
  <verify>
    `go build ./cmd/wf/` compiles.
    `wf edit --help` and `wf rm --help` show correct usage.
    Manual test flow:
    1. `wf add --name demo --command "echo {{msg}}" --tag test` — creates workflow
    2. `wf edit demo --description "A demo workflow"` — updates description field
    3. `wf rm demo --force` — deletes without confirmation
    4. Verify the YAML file no longer exists after rm
  </verify>
  <done>
    `wf edit` opens workflow in $EDITOR by default, supports quick field updates via flags. `wf rm` prompts for confirmation by default, `--force` skips it. Both print one-liner feedback. Both error on non-existent workflows.
  </done>
</task>

</tasks>

<verification>
1. `go build ./cmd/wf/` compiles cleanly
2. `wf add --name test --command "echo hello" --tag demo` creates valid YAML file
3. `wf edit test --description "updated"` modifies the workflow file correctly
4. `wf rm test --force` removes the workflow file
5. `wf add --help`, `wf edit --help`, `wf rm --help` all show proper usage
6. Commands use the store and template packages from Plans 01 and 02
</verification>

<success_criteria>
- `wf add` creates workflow files with all fields (name, command, description, tags, args)
- `wf add` prompts interactively when flags are missing
- `wf add` auto-extracts {{params}} from command string into args
- `wf edit` opens $EDITOR by default, supports quick flag-based updates
- `wf rm` confirms before deleting, `--force` skips confirmation
- All commands print minimal one-liner feedback
- All commands error gracefully on invalid input
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-layer/01-03-SUMMARY.md`
</output>
