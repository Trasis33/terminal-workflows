---
phase: 03-management-tui
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/manage/form.go
  - internal/manage/model.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "User can fill out a full-screen form to create a new workflow"
    - "User can edit an existing workflow in a pre-populated form"
    - "Form has fields for: name, description, command (multi-line), tags, folder"
    - "Tag input suggests existing tags as user types"
    - "Saving a form persists the workflow via Store.Save()"
    - "Esc from form returns to browse view without saving"
  artifacts:
    - path: "internal/manage/form.go"
      provides: "FormModel using huh for create/edit workflow forms"
      contains: "type FormModel struct"
      min_lines: 100
  key_links:
    - from: "internal/manage/form.go"
      to: "internal/store/store.go"
      via: "FormModel saves workflow via store.Save()"
      pattern: "store\\.Save"
    - from: "internal/manage/model.go"
      to: "internal/manage/form.go"
      via: "Root model routes viewCreate/viewEdit to FormModel"
      pattern: "m\\.form"
    - from: "internal/manage/form.go"
      to: "charmbracelet/huh"
      via: "Uses huh.Form for field layout and validation"
      pattern: "huh\\.NewForm|huh\\.NewInput|huh\\.NewText"
---

<objective>
Build the create/edit form view using the charmbracelet/huh form library. Full-screen form replaces the browse view, with fields for name, description, command (multi-line), tags, and folder path.

Purpose: Users need to create and edit workflows entirely from within the TUI (requirement MTUI-02). The form must handle multi-line commands and tag autocomplete without requiring $EDITOR handoff.
Output: FormModel that renders a full-screen huh form, saves via Store, and transitions back to browse on completion.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-management-tui/03-RESEARCH.md
@.planning/phases/03-management-tui/03-01-SUMMARY.md

# Store interface for persistence
@internal/store/store.go
@internal/store/workflow.go
@internal/store/yaml.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install huh dependency</name>
  <files>
    go.mod
    go.sum
  </files>
  <action>
Run `go get github.com/charmbracelet/huh@latest` to add the huh form library.

Verify it appears in go.mod. Run `go mod tidy` to clean up.

Note: huh may pull in additional transitive dependencies from the Charm ecosystem. This is expected and harmless since we already depend on bubbletea, bubbles, and lipgloss.
  </action>
  <verify>
`grep "charmbracelet/huh" go.mod` shows the dependency.
`go build ./...` compiles.
  </verify>
  <done>
huh form library added to go.mod, all packages compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: FormModel for create/edit workflows</name>
  <files>
    internal/manage/form.go
    internal/manage/model.go
  </files>
  <action>
**form.go — FormModel:**

Struct fields:
- `form *huh.Form` — the huh form instance
- `mode string` — "create" or "edit"
- `originalName string` — for edit mode: the original workflow name (to delete old file if name changes)
- `store store.Store`
- `width, height int`
- `theme Theme`
- Form data fields (bound to huh inputs via pointers):
  - `name string`
  - `description string`
  - `command string`
  - `tagInput string` — comma-separated tag string (simpler than custom autocomplete component for now)
  - `folder string`
- `existingTags []string` — for tag suggestions
- `existingFolders []string` — for folder suggestions
- `err error` — last save error, displayed in form

**Constructor: `NewFormModel(mode string, wf *store.Workflow, s store.Store, existingTags, existingFolders []string, theme Theme) FormModel`**
- If mode == "edit": pre-populate name, description, command, tags (joined with ", "), folder (extracted from workflow name path)
- If mode == "create": empty fields
- Build huh.Form with groups:
  ```
  huh.NewForm(
    huh.NewGroup(
      huh.NewInput().Title("Name").Value(&m.name).Validate(nameValidator),
      huh.NewInput().Title("Description").Value(&m.description),
      huh.NewText().Title("Command").Value(&m.command).Lines(8).Validate(commandValidator),
      huh.NewInput().Title("Tags (comma-separated)").Value(&m.tagInput).Placeholder("e.g., docker, deploy, infra"),
      huh.NewInput().Title("Folder").Value(&m.folder).Placeholder("e.g., infra/deploy (empty for root)"),
    ),
  ).WithTheme(huh.ThemeCharm()) // Use Charm theme as base, customize later if needed
  ```
- Name validator: non-empty, no path separators (folder is separate field)
- Command validator: non-empty

**Init() method:**
- Return `m.form.Init()` — huh handles initial focus

**Update(msg tea.Msg) method:**
- Check if huh form completed (`m.form.State == huh.StateCompleted`):
  - Parse tags from comma-separated tagInput: split on ",", trim whitespace, filter empty
  - Build workflow name: if folder non-empty, prefix with folder + "/" + name
  - Build store.Workflow struct from form fields
  - If edit mode and name changed: return tea.Cmd that deletes old name then saves new
  - Else: return tea.Cmd that saves workflow
  - On success: return `workflowSavedMsg{workflow}` then `switchToBrowseMsg{}`
  - On error: return `saveErrorMsg{err}`
- Check for form abort (huh.StateAborted or esc press):
  - Return `switchToBrowseMsg{}`
- Otherwise: forward msg to `m.form.Update(msg)`

**View() method:**
- Render form title: "Create Workflow" or "Edit Workflow" styled with theme
- Render `m.form.View()`
- If m.err != nil: render error message in red below form
- Render hints: "ctrl+c cancel  tab next field"

**Key conflict mitigation (research open question #1):**
- huh forms consume esc internally for field-level actions. Test whether esc properly aborts the form via `huh.WithKeyMap()` customization if needed.
- If huh consumes esc before parent can use it: set `form.WithKeyMap(customKeyMap)` where esc triggers form abort

**model.go updates:**
- Add `form FormModel` field to root Model
- Handle `switchToCreateMsg`: create new FormModel in "create" mode, set `m.state = viewCreate`
- Handle `switchToEditMsg`: create new FormModel in "edit" mode with pre-populated workflow, set `m.state = viewEdit`
- Handle `workflowSavedMsg`: refresh workflow list, switch to browse
- Handle `saveErrorMsg`: store error for display
- In Update(): when state is viewCreate or viewEdit, route to `m.form.Update(msg)`
- In View(): when state is viewCreate or viewEdit, return `m.form.View()`
  </action>
  <verify>
`go build ./internal/manage/...` compiles.
`go build ./cmd/wf/...` compiles.
`go test ./...` — all existing tests pass.
Write a unit test: create FormModel in create mode, verify form fields are empty. Create in edit mode with a workflow, verify fields pre-populated.
  </verify>
  <done>
FormModel renders a full-screen huh form for create/edit. Name and command validated as non-empty. Tags entered as comma-separated text. Folder field allows typing a path. Save persists via Store.Save(). Edit mode handles name changes (old file deleted). Esc/ctrl+c returns to browse without saving. Root model routes create/edit states to FormModel.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/manage/...` — compiles with huh dependency
2. `go vet ./internal/manage/...` — clean
3. `go test ./...` — all tests pass
4. huh form renders all 5 fields (name, description, command, tags, folder)
5. Form validation rejects empty name and empty command
6. Create mode: fields start empty, save creates new workflow
7. Edit mode: fields pre-populated from existing workflow
</verification>

<success_criteria>
- huh dependency in go.mod
- Full-screen form with 5 fields renders without panics
- Create mode saves a new workflow to Store
- Edit mode updates existing workflow, handles name/folder changes
- Esc cancels form and returns to browse
- Tags parsed from comma-separated input into []string
- Folder prefix applied to workflow name on save
</success_criteria>

<output>
After completion, create `.planning/phases/03-management-tui/03-03-SUMMARY.md`
</output>
