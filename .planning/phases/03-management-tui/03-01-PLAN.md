---
phase: 03-management-tui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/manage/theme.go
  - internal/manage/styles.go
  - internal/manage/keys.go
  - internal/manage/model.go
  - internal/manage/manage.go
autonomous: true

must_haves:
  truths:
    - "Theme struct loads from YAML and computes lipgloss styles"
    - "Default theme uses mint/cyan-green palette (ANSI 49, 158, 73) matching picker"
    - "Preset themes are available as Go constants"
    - "Root model routes messages to child views via viewState enum"
    - "WindowSizeMsg propagates to all child models"
  artifacts:
    - path: "internal/manage/theme.go"
      provides: "Theme struct, YAML load/save, DefaultTheme(), preset themes, computeStyles()"
      contains: "func DefaultTheme"
    - path: "internal/manage/styles.go"
      provides: "themeStyles struct with lipgloss.Style fields for all UI components"
      contains: "type themeStyles struct"
    - path: "internal/manage/keys.go"
      provides: "keyMap struct with all keybindings using bubbles/key"
      contains: "func defaultKeyMap"
    - path: "internal/manage/model.go"
      provides: "Root Model with viewState enum, Init/Update/View, message routing"
      contains: "type viewState int"
    - path: "internal/manage/manage.go"
      provides: "Public API: New() constructor, Run() entry point"
      exports: ["New", "Run"]
  key_links:
    - from: "internal/manage/model.go"
      to: "internal/manage/theme.go"
      via: "Model holds Theme, passes to child View() calls"
      pattern: "m\\.theme"
    - from: "internal/manage/model.go"
      to: "internal/store/store.go"
      via: "Model holds store.Store for persistence"
      pattern: "store\\.Store"
---

<objective>
Create the foundation for the management TUI: theme system with YAML persistence and presets, keybinding definitions, root model with view routing, and public API entry point.

Purpose: Every component in the management TUI depends on the theme system for styling and the root model for message routing. This plan establishes the scaffold that Plans 02-05 build upon.
Output: `internal/manage/` package with theme, styles, keys, root model, and public API — compiles but shows only a placeholder browse view.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-management-tui/03-RESEARCH.md

# Existing patterns to follow
@internal/picker/styles.go
@internal/picker/model.go
@internal/store/store.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Theme system + styles + keybindings</name>
  <files>
    internal/manage/theme.go
    internal/manage/styles.go
    internal/manage/keys.go
  </files>
  <action>
Create `internal/manage/` package with three files:

**theme.go:**
- `Theme` struct with YAML tags: Name, Colors (Primary/Secondary/Tertiary/Text/Dim/Border/Background), Borders (Style string), Layout (SidebarWidth int, ShowPreview bool)
- `themeStyles` struct (unexported, stored as `styles` field on Theme with `yaml:"-"`) containing lipgloss.Style fields: Sidebar, List, Preview, Selected, Highlight, Tag, Dim, Hint, DialogBox, DialogTitle, FormTitle, ActiveBorder, InactiveBorder
- `computeStyles()` method that converts Theme color strings to lipgloss.Style instances. Border style mapping: "rounded"->RoundedBorder, "normal"->NormalBorder, "thick"->ThickBorder, "double"->DoubleBorder, "hidden"->HiddenBorder
- `DefaultTheme()` returning mint/cyan-green palette: Primary="49", Secondary="158", Tertiary="73", Text="250", Dim="242", Border="238", Borders.Style="rounded", Layout.SidebarWidth=24, Layout.ShowPreview=true
- `LoadTheme(configDir string) (Theme, error)` reading from `<configDir>/theme.yaml` using goccy/go-yaml
- `SaveTheme(configDir string, t Theme) error` writing to `<configDir>/theme.yaml`
- Preset themes as package-level functions: `PresetDark()`, `PresetLight()`, `PresetDracula()`, `PresetNord()` — each returns a Theme with appropriate colors. `PresetNames()` returns []string of available preset names. `PresetByName(name string) (Theme, bool)` returns a preset by name.

**styles.go:**
- Re-export the `themeStyles` type definition if needed, OR keep it in theme.go (whichever is cleaner)
- This file contains the `Styles()` method on Theme that returns the computed `themeStyles` — a simple accessor: `func (t Theme) Styles() themeStyles { return t.styles }`

**keys.go:**
- `keyMap` struct using `github.com/charmbracelet/bubbles/key` with bindings: Up, Down, Enter, Back, Create, Edit, Delete, Move, Search, ToggleSidebar, Settings, Quit, Help, FolderCreate, FolderRename, FolderDelete
- `defaultKeyMap()` function returning sensible defaults:
  - Up: "up"/"k", Down: "down"/"j", Enter: "enter", Back: "esc"
  - Create: "n", Edit: "e", Delete: "d", Move: "m"
  - Search: "/", ToggleSidebar: "tab", Settings: "ctrl+t"
  - Quit: "q"/"ctrl+c", Help: "?"
  - FolderCreate: "N" (shift-n), FolderRename: "R" (shift-r), FolderDelete: "D" (shift-d)
- Implement `bubbles/help.KeyMap` interface on keyMap (ShortHelp/FullHelp methods)

Use goccy/go-yaml for YAML operations (NOT gopkg.in/yaml.v3 — see decision 01-01-D1). Use adrg/xdg for paths (already in go.mod).
  </action>
  <verify>
`go build ./internal/manage/...` compiles without errors.
`go vet ./internal/manage/...` passes.
Verify DefaultTheme().Colors.Primary == "49".
  </verify>
  <done>
Theme struct with YAML load/save, 5 preset themes (default + 4 named), computeStyles() producing lipgloss styles, and keybindings with help interface — all compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Root model + view router + public API</name>
  <files>
    internal/manage/model.go
    internal/manage/manage.go
  </files>
  <action>
**model.go:**
- `viewState` enum: `viewBrowse`, `viewCreate`, `viewEdit`, `viewSettings`
- Custom message types for view transitions:
  - `switchToEditMsg{workflow store.Workflow}`
  - `switchToCreateMsg{}`
  - `switchToBrowseMsg{}`
  - `switchToSettingsMsg{}`
  - `showDeleteDialogMsg{workflow store.Workflow}`
  - `deleteConfirmedMsg{workflow store.Workflow}`
  - `showFolderDialogMsg{action string}` (action: "create", "rename", "delete")
  - `refreshWorkflowsMsg{}`
  - `workflowSavedMsg{workflow store.Workflow}`
  - `saveErrorMsg{err error}`
  - `themeSavedMsg{}`
  - `moveWorkflowMsg{workflow store.Workflow}`
- `Model` struct with fields:
  - `state viewState`, `prevState viewState`
  - `store store.Store` (interface, not concrete — for testability)
  - `workflows []store.Workflow`
  - `theme Theme`
  - `keys keyMap`
  - `width, height int`
  - `configDir string` (for theme save path)
  - Placeholder child model fields (initially nil/empty — Plans 02-04 will populate):
    - `browseReady bool` (set false initially)
  - `dialog *dialogState` (nil when no dialog active) — define `dialogState` as a simple struct with `title string`, `message string`, `onConfirm tea.Cmd`
- `Init()` returns `tea.WindowSize` command (triggers initial layout)
- `Update()`:
  1. Handle `tea.WindowSizeMsg` first — update m.width/m.height, store for child propagation
  2. Handle custom transition messages (switchToEditMsg, etc.)
  3. Handle `refreshWorkflowsMsg` — reload workflows from store via tea.Cmd
  4. Route to active view's update method based on m.state
  5. For now, browse state handles basic quit (q/ctrl+c → tea.Quit)
- `View()`:
  1. Switch on m.state, delegate to child View methods
  2. For now, render a placeholder: centered "wf manage" title + workflow count + hint bar
  3. If dialog active, render overlay (placeholder for now — just show dialog.title centered)

**manage.go:**
- `New(s store.Store, workflows []store.Workflow, theme Theme, configDir string) Model` constructor
- `Run(s store.Store) error` convenience function that loads workflows, loads theme (with fallback to DefaultTheme), creates Model, runs `tea.NewProgram(model, tea.WithAltScreen())` and returns error. This is what the cobra command will call.

Important: Use `tea.WithAltScreen()` for full-screen mode. The picker does NOT use alt screen (inline), but the management TUI MUST (full-screen).
  </action>
  <verify>
`go build ./internal/manage/...` compiles.
Write a quick test in a temporary main or test file: create a Model with `New()`, verify `model.state == viewBrowse`, verify `model.theme.Colors.Primary == "49"`.
`go test ./internal/manage/...` passes.
  </verify>
  <done>
Root model compiles, routes messages by viewState, handles WindowSizeMsg, has custom message types for all view transitions, and Run() can launch a full-screen alt-screen Bubble Tea program showing a placeholder browse view with workflow count.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/manage/...` — package compiles
2. `go vet ./internal/manage/...` — no issues
3. `go test ./internal/manage/...` — tests pass
4. `go build ./cmd/wf/...` — full binary still compiles (no import cycle)
5. Theme YAML round-trip: DefaultTheme() → SaveTheme() → LoadTheme() produces identical Theme
</verification>

<success_criteria>
- `internal/manage/` package exists with 5 files (theme.go, styles.go, keys.go, model.go, manage.go)
- Theme system: DefaultTheme() returns mint palette, 4 named presets available, YAML load/save works
- Root model: viewState enum with 4 states, message routing scaffold, placeholder View
- Public API: New() + Run() allow launching the TUI
- All existing tests still pass: `go test ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/03-management-tui/03-01-SUMMARY.md`
</output>
