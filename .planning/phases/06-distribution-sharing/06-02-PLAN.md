---
phase: 06-distribution-sharing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/remote.go
  - internal/store/multi.go
autonomous: true

must_haves:
  truths:
    - "RemoteStore can list workflows from a cloned repo directory"
    - "RemoteStore is read-only (Save/Delete return errors)"
    - "RemoteStore skips .git directory and malformed YAML files"
    - "MultiStore aggregates local and remote store results"
    - "Remote workflows are prefixed with source alias in MultiStore.List"
    - "MultiStore.Get resolves alias/name prefix to correct remote store"
    - "Failed remote stores log warnings but don't break List"
  artifacts:
    - path: "internal/store/remote.go"
      provides: "Read-only Store implementation for cloned repos"
      exports: ["RemoteStore", "NewRemoteStore"]
    - path: "internal/store/multi.go"
      provides: "Aggregating Store over local + remote stores"
      exports: ["MultiStore", "NewMultiStore"]
  key_links:
    - from: "internal/store/multi.go"
      to: "internal/store/store.go"
      via: "implements Store interface"
      pattern: "func.*MultiStore.*List"
    - from: "internal/store/remote.go"
      to: "internal/store/store.go"
      via: "implements Store interface"
      pattern: "func.*RemoteStore.*List"
---

<objective>
Create RemoteStore (read-only Store for cloned repos) and MultiStore (aggregates local + remote stores with alias prefixing).

Purpose: These store implementations let the picker and TUI seamlessly search across local and remote workflow sources. RemoteStore wraps a cloned git repo directory, MultiStore merges results with alias-based namespacing.

Output: internal/store/remote.go, internal/store/multi.go
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-distribution-sharing/06-RESEARCH.md
@internal/store/store.go
@internal/store/yaml.go
@internal/store/workflow.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: RemoteStore — read-only Store for cloned repos</name>
  <files>internal/store/remote.go</files>
  <action>
Create internal/store/remote.go in package `store`:

**RemoteStore struct:**
```go
type RemoteStore struct {
    dir string // path to cloned repo root
}
```

- `NewRemoteStore(dir string) *RemoteStore` — constructor.

**List() ([]Workflow, error):**
- Walk entire `rs.dir` using `filepath.WalkDir`
- Skip `.git` directory: if `d.Name() == ".git" && d.IsDir()` return `filepath.SkipDir`
- Only process files ending in `.yaml` or `.yml`
- For each YAML file: read, unmarshal to Workflow. If unmarshal fails OR workflow has empty Name or Command field, skip silently (remote repos may have non-workflow YAML files like README metadata)
- Return collected workflows

**Get(name string) (*Workflow, error):**
- Call List(), iterate to find matching name. This is simple and correct for read-only repos (no slug-based path assumption like YAMLStore).

**Save(w *Workflow) error:** return `fmt.Errorf("cannot save to remote source (read-only)")`

**Delete(name string) error:** return `fmt.Errorf("cannot delete from remote source (read-only)")`

Key difference from YAMLStore: no depth limit (remote repos can have any structure), skip `.git`, skip malformed files silently, no WorkflowPath since we don't need filesystem-based lookup.
  </action>
  <verify>
  `go build ./internal/store/...` compiles. `go vet ./internal/store/...` passes.
  </verify>
  <done>
  RemoteStore walks cloned repo, returns workflows, skips .git and malformed files, and is read-only.
  </done>
</task>

<task type="auto">
  <name>Task 2: MultiStore — aggregating Store with alias prefixing</name>
  <files>internal/store/multi.go</files>
  <action>
Create internal/store/multi.go in package `store`:

**MultiStore struct:**
```go
type MultiStore struct {
    local  Store
    remote map[string]Store // key = source alias
}
```

- `NewMultiStore(local Store, remote map[string]Store) *MultiStore` — constructor. If remote is nil, initialize to empty map.

**List() ([]Workflow, error):**
1. Get local workflows first (no prefix). If local.List() errors, return error (local is critical).
2. For each remote store (sorted by alias for deterministic order):
   - Call s.List(). If error, `fmt.Fprintf(os.Stderr, "warning: source %q: %v\n", alias, err)` and continue (don't fail).
   - For each workflow: set `w.Name = alias + "/" + w.Name` (namespace prefix)
   - Append to results
3. Return all workflows.

**Get(name string) (*Workflow, error):**
1. Check if name contains `/`: if yes, split on first `/` to get alias and remainder.
2. If alias matches a remote store key, delegate to that store's Get with the remainder name.
3. If no `/` or alias doesn't match any remote, delegate to local store.

**Save(w *Workflow) error:**
- If name starts with a known remote alias + "/", return read-only error.
- Otherwise delegate to local store.

**Delete(name string) error:**
- Same prefix check as Save. Block remote deletes, delegate local.

**HasRemote() bool** — returns len(ms.remote) > 0. Useful for UI to know if source labels should be shown.

Import `sort` for deterministic remote ordering. Import `fmt` and `os` for stderr warning.
  </action>
  <verify>
  `go build ./internal/store/...` compiles. `go vet ./internal/store/...` passes.
  </verify>
  <done>
  MultiStore.List returns local workflows (no prefix) + remote workflows (alias-prefixed). Get/Save/Delete handle alias routing. Remote errors logged as warnings without failing.
  </done>
</task>

</tasks>

<verification>
```bash
go build ./internal/store/...
go vet ./internal/store/...
go test ./... 2>&1 | tail -5  # Existing tests still pass
```
</verification>

<success_criteria>
- RemoteStore and MultiStore implement the Store interface
- RemoteStore walks dirs, skips .git, handles malformed files gracefully
- MultiStore merges local + remote with alias namespacing
- Remote store failures are warnings, not errors
- Existing store tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-distribution-sharing/06-02-SUMMARY.md`
</output>
