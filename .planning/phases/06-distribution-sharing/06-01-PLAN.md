---
phase: 06-distribution-sharing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/config/config.go
  - internal/source/manager.go
  - internal/source/git.go
autonomous: true

must_haves:
  truths:
    - "SourcesDir() returns XDG data home path for wf sources"
    - "Source manager can add a source by cloning a git repo with alias"
    - "Source manager can remove a source by deleting clone and config entry"
    - "Source manager can update a source via git pull and report changes"
    - "Source manager can list all configured sources"
    - "Git operations fail gracefully when git is not installed"
    - "Git clone does not hang on auth prompts (GIT_TERMINAL_PROMPT=0)"
  artifacts:
    - path: "internal/config/config.go"
      provides: "SourcesDir() function"
      contains: "SourcesDir"
    - path: "internal/source/manager.go"
      provides: "Source CRUD (Add, Remove, Update, List)"
      exports: ["Manager", "Source", "NewManager"]
    - path: "internal/source/git.go"
      provides: "Git operations (clone, pull, availability check)"
      exports: ["gitClone", "gitPull", "gitAvailable"]
  key_links:
    - from: "internal/source/manager.go"
      to: "internal/source/git.go"
      via: "gitClone/gitPull calls"
      pattern: "git(Clone|Pull)"
    - from: "internal/source/manager.go"
      to: "internal/config/config.go"
      via: "config.SourcesDir() for clone directory"
      pattern: "SourcesDir"
---

<objective>
Create the source management foundation: git operations wrapper, source manager with CRUD, and config extension for data directory.

Purpose: This is the backend plumbing for git-based workflow sharing — the Manager handles add/remove/update/list of remote sources, git.go wraps os/exec git commands with proper timeouts and error handling, and config.go gains SourcesDir() for clone storage.

Output: internal/source/manager.go, internal/source/git.go, modified internal/config/config.go
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-distribution-sharing/06-RESEARCH.md
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config extension + Git operations wrapper</name>
  <files>internal/config/config.go, internal/source/git.go</files>
  <action>
1. In internal/config/config.go, add `SourcesDir()` function that returns `filepath.Join(xdg.DataHome, "wf", "sources")`. Add `EnsureSourcesDir()` that calls `os.MkdirAll` on SourcesDir(). This follows the existing pattern of WorkflowsDir()/EnsureDir().

2. Create internal/source/git.go with package `source`:
   - `gitAvailable() bool` — checks `exec.LookPath("git")`, returns true/false
   - `gitClone(ctx context.Context, url, dest string) error` — runs `git clone --depth 1 <url> <dest>` with 2-minute timeout via `context.WithTimeout`. Set env `GIT_TERMINAL_PROMPT=0` to prevent auth prompts from hanging. Route stderr to os.Stderr for progress output. Wrap errors with `fmt.Errorf("git clone %s: %w", url, err)`.
   - `gitPull(ctx context.Context, repoDir string) (string, error)` — runs `git pull --ff-only` in repoDir with 30-second timeout. Set `GIT_TERMINAL_PROMPT=0`. Return combined stdout+stderr output. Wrap errors.
   - `deriveAlias(url string) string` — strips `.git` suffix, takes last path segment via `strings.FieldsFunc` splitting on `/` and `:`. Returns `"remote"` as fallback if empty.

Use `os/exec` only (no go-git). All exec.Command calls must set `cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")`.
  </action>
  <verify>
  `go build ./internal/config/... ./internal/source/...` compiles without errors.
  `go vet ./internal/config/... ./internal/source/...` passes.
  </verify>
  <done>
  config.SourcesDir() returns correct XDG data path. git.go compiles with clone/pull/available/deriveAlias functions. GIT_TERMINAL_PROMPT=0 is set on all git commands.
  </done>
</task>

<task type="auto">
  <name>Task 2: Source manager with CRUD operations</name>
  <files>internal/source/manager.go</files>
  <action>
Create internal/source/manager.go with package `source`:

**Types:**
```go
type Source struct {
    Alias     string    `yaml:"alias"`
    URL       string    `yaml:"url"`
    UpdatedAt time.Time `yaml:"updated_at,omitempty"`
}

type sourceConfig struct {
    Sources []Source `yaml:"sources"`
}

type Manager struct {
    dir string       // base directory for clones (config.SourcesDir())
    cfg sourceConfig // loaded from sources.yaml
}
```

**Functions:**
- `NewManager(dir string) *Manager` — creates Manager, calls `load()` to read sources.yaml. If file doesn't exist, initializes empty config.
- `(m *Manager) Add(ctx context.Context, url, alias string) error`:
  1. Check `gitAvailable()` — return clear error if false: "git is required for remote sources. Install git and try again"
  2. If alias is empty, call `deriveAlias(url)`
  3. Check `m.hasAlias(alias)` — return error if collision: "source %q already exists. Use --name to specify a different alias"
  4. Clone to `filepath.Join(m.dir, alias)` via `gitClone`
  5. Append Source to config, set UpdatedAt to time.Now()
  6. Call `m.save()` to persist sources.yaml
- `(m *Manager) Remove(alias string) error`:
  1. Find source by alias — error if not found
  2. Remove clone directory via `os.RemoveAll(filepath.Join(m.dir, alias))`
  3. Remove from config slice
  4. Call `m.save()`
- `(m *Manager) Update(ctx context.Context, alias string) (*UpdateResult, error)`:
  1. Find source by alias — error if not found
  2. Snapshot: list .yaml files in clone dir before pull (just filenames)
  3. Call `gitPull(ctx, filepath.Join(m.dir, alias))`
  4. Snapshot: list .yaml files after pull
  5. Compare: compute added, removed, updated (by modification time)
  6. Update source.UpdatedAt, call `m.save()`
  7. Return `UpdateResult{Added []string, Removed []string, Updated []string}`
- `(m *Manager) List() []Source` — returns copy of m.cfg.Sources
- `(m *Manager) SourceDirs() map[string]string` — returns alias→clone directory path map for building RemoteStores
- Private helpers: `load()`, `save()`, `hasAlias(alias string) bool`, `configPath() string` (returns filepath.Join(m.dir, "sources.yaml"))

Use goccy/go-yaml for sources.yaml (consistent with project). Use `os.MkdirAll(m.dir, 0755)` in save() to ensure directory exists.

The `UpdateResult` struct should have exported fields for the CLI to display.
  </action>
  <verify>
  `go build ./internal/source/...` compiles.
  `go vet ./internal/source/...` passes.
  </verify>
  <done>
  Manager can Add (with git check, alias derivation, collision check), Remove (cleanup dir + config), Update (with diff summary), List, and SourceDirs. Config persisted to sources.yaml. UpdateResult struct carries diff info.
  </done>
</task>

</tasks>

<verification>
```bash
go build ./internal/config/... ./internal/source/...
go vet ./internal/config/... ./internal/source/...
go test ./... 2>&1 | tail -5  # Existing tests still pass
```
</verification>

<success_criteria>
- internal/source/manager.go and internal/source/git.go exist and compile
- config.SourcesDir() returns xdg.DataHome/wf/sources path
- Manager.Add clones repos, Manager.Remove cleans up, Manager.Update pulls and diffs
- All git operations use GIT_TERMINAL_PROMPT=0 and timeouts
- Existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-distribution-sharing/06-01-SUMMARY.md`
</output>
