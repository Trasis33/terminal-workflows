---
phase: 06-distribution-sharing
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - cmd/wf/source.go
  - cmd/wf/root.go
  - cmd/wf/pick.go
  - cmd/wf/manage.go
  - cmd/wf/list.go
autonomous: true

must_haves:
  truths:
    - "User can run `wf source add <url>` and it clones the repo"
    - "User can run `wf source add <url> --name <alias>` for custom alias"
    - "User can run `wf source remove <alias>` and it removes the source"
    - "User can run `wf source update [alias]` and see diff summary"
    - "User can run `wf source list` and see all configured sources"
    - "Remote workflows appear in picker search results with alias prefix"
    - "Remote workflows appear in manage TUI browse view"
    - "wf list shows remote workflows alongside local ones"
    - "`wf source` commands fail gracefully when git is not installed"
  artifacts:
    - path: "cmd/wf/source.go"
      provides: "wf source add/remove/update/list subcommands"
      exports: ["sourceCmd"]
    - path: "cmd/wf/root.go"
      provides: "sourceCmd registered + getMultiStore helper"
      contains: "sourceCmd"
    - path: "cmd/wf/pick.go"
      provides: "Picker uses MultiStore for workflow loading"
      contains: "getMultiStore"
    - path: "cmd/wf/manage.go"
      provides: "Manage TUI uses MultiStore"
      contains: "getMultiStore"
  key_links:
    - from: "cmd/wf/source.go"
      to: "internal/source/manager.go"
      via: "source.NewManager(config.SourcesDir())"
      pattern: "source\\.NewManager"
    - from: "cmd/wf/root.go"
      to: "internal/store/multi.go"
      via: "getMultiStore() returns MultiStore"
      pattern: "store\\.NewMultiStore"
    - from: "cmd/wf/pick.go"
      to: "cmd/wf/root.go"
      via: "getMultiStore() for workflow loading"
      pattern: "getMultiStore"
---

<objective>
Wire source management CLI commands and integrate MultiStore into picker, manage TUI, and list command so remote workflows appear alongside local ones.

Purpose: This is the user-facing integration — the `wf source` subcommand tree lets users manage remote sources, and the MultiStore wiring makes remote workflows searchable in picker and TUI.

Output: cmd/wf/source.go (new), modified cmd/wf/root.go, cmd/wf/pick.go, cmd/wf/manage.go, cmd/wf/list.go
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-distribution-sharing/06-RESEARCH.md
@.planning/phases/06-distribution-sharing/06-01-SUMMARY.md
@.planning/phases/06-distribution-sharing/06-02-SUMMARY.md
@cmd/wf/root.go
@cmd/wf/pick.go
@cmd/wf/manage.go
@cmd/wf/init_shell.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Source CLI commands (wf source add/remove/update/list)</name>
  <files>cmd/wf/source.go</files>
  <action>
Create cmd/wf/source.go with the `wf source` command group:

**Parent command:** `sourceCmd` — `Use: "source"`, Short: "Manage remote workflow sources"

**Subcommands:**

1. `sourceAddCmd` — `Use: "add <git-url>"`, Args: cobra.ExactArgs(1)
   - Flag: `--name` string for custom alias
   - RunE: create `source.NewManager(config.SourcesDir())`, call `mgr.Add(cmd.Context(), args[0], nameFlag)`
   - Print success: `fmt.Fprintf(os.Stderr, "Added source %q from %s\n", alias, url)`
   - On error, print the error message (git not installed, alias collision, clone failure)

2. `sourceRemoveCmd` — `Use: "remove <alias>"`, Args: cobra.ExactArgs(1)
   - ValidArgsFunction: load source list for tab completion (as shown in 06-RESEARCH.md cobra completions example)
   - RunE: call `mgr.Remove(args[0])`
   - Print: `fmt.Fprintf(os.Stderr, "Removed source %q\n", args[0])`

3. `sourceUpdateCmd` — `Use: "update [alias]"`, Args: cobra.MaximumNArgs(1)
   - If alias provided: update that one source. If no alias: update ALL sources.
   - Print diff summary from UpdateResult: "Source <alias>: +N new, -N removed, ~N updated" for each source
   - If no changes: "Source <alias>: already up to date"

4. `sourceListCmd` — `Use: "list"`, Args: cobra.NoArgs
   - Print table: alias, URL, last updated (formatted as relative time or date)
   - If no sources: "No remote sources configured. Use 'wf source add <git-url>' to add one."

Wire subcommands: `sourceCmd.AddCommand(sourceAddCmd, sourceRemoveCmd, sourceUpdateCmd, sourceListCmd)`

All commands should call `config.EnsureSourcesDir()` before creating the Manager (in the parent PersistentPreRunE or at start of each RunE).
  </action>
  <verify>
  `go build ./cmd/wf/...` compiles. `go vet ./cmd/wf/...` passes.
  Run `go run ./cmd/wf source --help` and verify subcommands are listed.
  </verify>
  <done>
  `wf source add/remove/update/list` subcommands exist, call source.Manager, and produce user-friendly output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire MultiStore into root, pick, manage, and list</name>
  <files>cmd/wf/root.go, cmd/wf/pick.go, cmd/wf/manage.go, cmd/wf/list.go</files>
  <action>
1. **cmd/wf/root.go:**
   - Add `sourceCmd` to init(): `rootCmd.AddCommand(sourceCmd)`
   - Add `getMultiStore() store.Store` function:
     ```go
     func getMultiStore() store.Store {
         local := getStore()
         mgr := source.NewManager(config.SourcesDir())
         sources := mgr.SourceDirs()
         if len(sources) == 0 {
             return local // No remote sources, return local directly
         }
         remote := make(map[string]store.Store)
         for alias, dir := range sources {
             remote[alias] = store.NewRemoteStore(dir)
         }
         return store.NewMultiStore(local, remote)
     }
     ```
   - Add imports for `source` and `store` packages as needed.

2. **cmd/wf/pick.go:**
   - Change `s := getStore()` to `s := getMultiStore()` in runPick.
   - This is a one-line change. The rest of the picker flow (List, parameter fill) works unchanged since MultiStore implements Store.

3. **cmd/wf/manage.go:**
   - Change `manage.Run(getStore())` to `manage.Run(getMultiStore())`.
   - Check if manage.Run accepts `store.Store` interface or `*store.YAMLStore` concrete type. If it accepts concrete type, update manage.Run signature to accept `store.Store` interface. The manage package uses List/Get/Save/Delete which are all on the interface.

4. **cmd/wf/list.go:**
   - Change getStore() to getMultiStore() for the list command's store access.
   - Remote workflows will show with their alias/ prefix in the list output, providing natural source distinction.

Note: If manage.Run or any other consumer uses `*store.YAMLStore` instead of `store.Store`, update the function signature to accept the interface. The Store interface has all needed methods. Check the actual signatures before modifying.
  </action>
  <verify>
  `go build ./cmd/wf/...` compiles. `go vet ./cmd/wf/...` passes. `go test ./...` passes (existing tests still work since getStore() unchanged, getMultiStore is additive).
  Run `go run ./cmd/wf source list` to verify it produces "No remote sources" output.
  Run `go run ./cmd/wf list` to verify existing local workflows still appear.
  </verify>
  <done>
  sourceCmd registered in root. getMultiStore() returns MultiStore when remote sources exist, plain local store when none. Picker, manage TUI, and list command all use getMultiStore() — remote workflows appear in all views. Existing workflows unaffected.
  </done>
</task>

</tasks>

<verification>
```bash
go build ./cmd/wf/...
go vet ./cmd/wf/...
go test ./...
go run ./cmd/wf source --help
go run ./cmd/wf source list
go run ./cmd/wf list
```
</verification>

<success_criteria>
- `wf source add/remove/update/list` commands work end-to-end
- Remote workflows appear in picker, manage TUI, and list output
- Existing local-only workflow path is unchanged (no performance regression)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-distribution-sharing/06-03-SUMMARY.md`
</output>
