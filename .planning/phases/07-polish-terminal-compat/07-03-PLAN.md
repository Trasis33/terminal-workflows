---
phase: 07-polish-terminal-compat
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/manage/browse.go
  - internal/manage/sidebar.go
  - internal/manage/model.go
  - internal/manage/model_test.go
  - internal/picker/model.go
  - cmd/wf/list.go
autonomous: true
requirements: [MGUX-01, MGUX-02, DISP-01, DISP-02]

must_haves:
  truths:
    - "User navigating to a folder in sidebar sees workflow list filter instantly without pressing Enter"
    - "User sees folder breadcrumb at top of workflow list indicating active filter"
    - "User sees 'All Workflows' at top of sidebar and selecting it clears the filter"
    - "User sees empty state message when selected folder has no workflows"
    - "User sees syntax-highlighted command in the manage preview pane"
    - "User sees syntax-highlighted command in the picker preview pane"
    - "User scrolling preview hits a natural stop at end of content, no blank overscroll"
    - "User sees scroll position indicator in preview pane"
    - "User running wf list sees workflows with ANSI-colored folder, name, and tags"
  artifacts:
    - path: "internal/manage/sidebar.go"
      provides: "Auto-filter on cursor move (emits sidebarFilterMsg on every moveCursor)"
    - path: "internal/manage/browse.go"
      provides: "Viewport-based preview with syntax highlighting, breadcrumb, scroll indicator"
    - path: "cmd/wf/list.go"
      provides: "ANSI-colored wf list output"
  key_links:
    - from: "internal/manage/browse.go"
      to: "internal/highlight/highlight.go"
      via: "highlight.Shell() in renderPreview"
      pattern: "highlight\\.Shell"
    - from: "internal/picker/model.go"
      to: "internal/highlight/highlight.go"
      via: "highlight.Shell() in updatePreview"
      pattern: "highlight\\.Shell"
    - from: "internal/manage/sidebar.go"
      to: "internal/manage/browse.go"
      via: "sidebarFilterMsg on every cursor move"
      pattern: "sidebarFilterMsg"
    - from: "internal/manage/browse.go"
      to: "bubbles/viewport"
      via: "viewport.Model for scrollable preview"
      pattern: "viewport\\.Model"
---

<objective>
Integrate syntax highlighting into the manage TUI, add sidebar auto-filtering, replace raw preview rendering with viewport-based scrollable preview, and add ANSI coloring to wf list CLI output.

Purpose: Complete the user-facing polish ‚Äî highlighted commands (DISP-01, DISP-02), instant folder navigation (MGUX-01), bounded preview scrolling (MGUX-02), and CLI list coloring.

Output: Updated manage TUI with highlighting + UX fixes, colored wf list output.
</objective>

<execution_context>
@/Users/fredriklanga/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/fredriklanga/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-terminal-compat/07-CONTEXT.md
@.planning/phases/07-polish-terminal-compat/07-RESEARCH.md
@.planning/phases/07-polish-terminal-compat/07-01-SUMMARY.md
</context>

<interfaces>
<!-- Key interfaces from Plan 01 output (highlight package). -->

From internal/highlight/highlight.go (created by Plan 01):
```go
// TokenStyles maps Chroma token types to lipgloss styles.
type TokenStyles map[chroma.TokenType]lipgloss.Style

// TokenStylesFromColors creates token styles from ANSI-256 color codes.
func TokenStylesFromColors(primary, secondary, tertiary, dim, text string) TokenStyles

// Shell highlights a shell command string using Chroma bash lexer and lipgloss styling.
// Template parameters {{name}} are highlighted with accent color.
// Returns original command on any error (graceful degradation).
func Shell(command string, styles TokenStyles) string
```

From internal/manage/browse.go (current ‚Äî to be modified):
```go
type BrowseModel struct {
    sidebar   SidebarModel
    focus     focusArea
    workflows []store.Workflow
    filtered  []store.Workflow
    cursor    int
    scrollOff int
    // ... search fields, theme, keys, dimensions ...
}

func (b BrowseModel) previewHeight() int { return 6 }  // fixed preview height

func (b BrowseModel) renderPreview() string {
    // Currently shows raw wf.Command text with theme styling
    // Needs: syntax highlighting via highlight.Shell() + viewport
}
```

From internal/manage/sidebar.go (current ‚Äî to be modified):
```go
func (s SidebarModel) Update(msg tea.Msg) (SidebarModel, tea.Cmd) {
    // Currently only emits sidebarFilterMsg on "enter" key
    // Needs: emit on every cursor move (up/down/j/k)
}
```

From internal/manage/theme.go:
```go
type themeColors struct {
    Primary, Secondary, Tertiary, Text, Dim, Border, Background string
}
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Sidebar auto-filter on cursor move and breadcrumb display</name>
  <files>internal/manage/sidebar.go, internal/manage/browse.go, internal/manage/model_test.go</files>
  <action>
**Modify `internal/manage/sidebar.go`:**

1. Change `Update()` to emit `sidebarFilterMsg` on every cursor movement, not just Enter. When handling "up"/"k" and "down"/"j" keys: after calling `s.moveCursor(delta)`, get the new filter with `s.SelectedFilter()` and return a command that sends `sidebarFilterMsg{filterType: ft, filterValue: fv}`. 

2. Keep "enter" handling the same (it also emits the filter ‚Äî redundant now but harmless for users who press Enter out of habit).

The key insight: currently moveCursor is called but no tea.Cmd is returned from cursor movement. After the change, every cursor move triggers a filter update.

**Modify `internal/manage/browse.go`:**

1. **Add breadcrumb rendering.** Add a `renderBreadcrumb()` method that returns a styled string:
   - When `b.filterType == "folder"`: render the theme's Highlight style with folder path, e.g., `s.Highlight.Render("üìÅ " + b.filterValue + "/")` 
   - When `b.filterType == "tag"`: render `s.Tag.Render("üè∑  " + b.filterValue)`
   - When no filter: render `s.Dim.Render("All Workflows")`

2. **Add breadcrumb to View().** In the `View()` method, add the breadcrumb string above the workflow list pane (between the search bar section and the `topPane` rendering). Show it as a line like: `breadcrumb := b.renderBreadcrumb()` and prepend to sections before `topPane`.

3. **Empty state.** The existing `renderList()` already shows "No workflows found" when `b.filtered` is empty. Update this to be context-aware: if `b.filterType == "folder"`, show `"No workflows in " + b.filterValue + "/"`. If `b.filterType == "tag"`, show `"No workflows tagged " + b.filterValue`. Otherwise keep the existing "No workflows found".

**Update tests in `internal/manage/model_test.go`:**
- Add test verifying that sidebar cursor move produces sidebarFilterMsg (send "down" key to sidebar, check returned tea.Cmd produces sidebarFilterMsg)
  </action>
  <verify>
```bash
go build ./internal/manage/... && go test ./internal/manage/... -v -count=1
```
  </verify>
  <done>
  - Sidebar emits filter on every cursor move (up/down/j/k), not just Enter
  - Breadcrumb shows current folder/tag/all filter at top of list
  - Empty state message is context-aware (mentions folder/tag name)
  - Tests verify auto-filter behavior
  </done>
</task>

<task type="auto">
  <name>Task 2: Viewport preview with syntax highlighting, scroll bounds, and wf list ANSI coloring</name>
  <files>internal/manage/browse.go, internal/manage/model.go, internal/picker/model.go, cmd/wf/list.go</files>
  <action>
**Modify `internal/manage/browse.go`:**

1. **Add viewport import and field.** Add `"github.com/charmbracelet/bubbles/viewport"` import. Add `previewVP viewport.Model` and `tokenStyles highlight.TokenStyles` fields to `BrowseModel` struct. Also add `"github.com/fredriklanga/wf/internal/highlight"` import.

2. **Initialize in NewBrowseModel.** In the constructor:
   ```go
   b.tokenStyles = highlight.TokenStylesFromColors(
       theme.Colors.Primary, theme.Colors.Secondary,
       theme.Colors.Tertiary, theme.Colors.Dim, theme.Colors.Text,
   )
   b.previewVP = viewport.New(0, 4) // width set later in SetDimensions
   ```

3. **Update SetDimensions** to set viewport dimensions:
   ```go
   previewW := width - 4 // borders/padding
   if previewW < 20 { previewW = 20 }
   b.previewVP.Width = previewW
   b.previewVP.Height = 4 // content lines (total preview = 4 content + 2 border = 6)
   ```

4. **Add `updatePreviewContent()` method** that sets viewport content when cursor changes:
   ```go
   func (b *BrowseModel) updatePreviewContent() {
       if len(b.filtered) == 0 || b.cursor >= len(b.filtered) {
           b.previewVP.SetContent("")
           return
       }
       wf := b.filtered[b.cursor]
       // Build preview content with highlighting
       var parts []string
       highlighted := highlight.Shell(wf.Command, b.tokenStyles)
       parts = append(parts, highlighted)
       if idx := strings.LastIndex(wf.Name, "/"); idx >= 0 {
           parts = append(parts, s.Dim.Render("Folder: ")+wf.Name[:idx])
       }
       if len(wf.Tags) > 0 {
           parts = append(parts, s.Dim.Render("Tags:   ")+s.Tag.Render(strings.Join(wf.Tags, ", ")))
       }
       if wf.Description != "" {
           parts = append(parts, s.Dim.Render("Desc:   ")+wf.Description)
       }
       b.previewVP.SetContent(strings.Join(parts, "\n"))
       b.previewVP.GotoTop()
   }
   ```
   Call this after `applyFilter()` and after any cursor movement.

5. **Route viewport keys.** When the list has focus, handle "ctrl+down"/"ctrl+up" or "J"/"K" (shift+j/shift+k) to scroll the preview pane without moving the list cursor:
   ```go
   case "J": // Shift+J scrolls preview down
       b.previewVP.LineDown(1)
       return b, nil
   case "K": // Shift+K scrolls preview up
       b.previewVP.LineUp(1)
       return b, nil
   ```

6. **Add scroll indicator to preview rendering.** In `View()`, replace the raw `renderPreview()` call with the viewport view. Add a scroll position indicator. After the viewport render, if content is taller than viewport, append a dim indicator like `"line X/Y"` or `"‚Üì more"` at the bottom-right of the preview border. Calculate: if `b.previewVP.TotalLineCount() > b.previewVP.Height`, show `fmt.Sprintf("%d%%", b.previewVP.ScrollPercent()*100)` in the dim style.

7. **Delete old `renderPreview()` method** ‚Äî replaced by viewport rendering + `updatePreviewContent()`.

8. **Update hints bar** ‚Äî add "J/K scroll preview" hint when preview has scrollable content.

**Modify `internal/manage/model.go`** if needed:
- Ensure `updateBrowse()` correctly passes viewport-related messages (tea.KeyMsg is already handled, but viewport may need WindowSizeMsg ‚Äî check if SetDimensions handles this).

**Modify `cmd/wf/list.go`:**

Add simple ANSI coloring for `wf list` output. Per CONTEXT decision: "simpler ANSI-native highlighting that separates folder, workflow name, and tags (uses terminal-native colors, not wf theme)". Use lipgloss for CLI output (already a dep, handles NO_COLOR automatically):

**Modify `internal/picker/model.go`:**

Add syntax highlighting to the picker's preview pane (Surface 2 per user locked decision). The picker already has a `preview viewport.Model` and an `updatePreview()` method that sets content to `m.results[m.cursor].Workflow.Command`. Changes:

1. Add `highlight` import: `"github.com/fredriklanga/wf/internal/highlight"`
2. Add `tokenStyles highlight.TokenStyles` field to `Model` struct
3. In the constructor (wherever Model is initialized), create token styles. The picker uses its own styles ‚Äî look for how the picker gets theme colors. If the picker doesn't have direct access to themeColors, use hardcoded ANSI-256 defaults that match the default theme (the picker has its own lipgloss styles in `internal/picker/styles.go` ‚Äî extract colors from there, or pass colors from the caller). The simplest approach: add a `TokenStyles` parameter to `NewModel()` (or similar constructor) and have the caller pass `highlight.TokenStylesFromColors(...)`.
4. In `updatePreview()`, change:
   ```go
   // Before:
   m.preview.SetContent(m.results[m.cursor].Workflow.Command)
   // After:
   cmd := m.results[m.cursor].Workflow.Command
   m.preview.SetContent(highlight.Shell(cmd, m.tokenStyles))
   ```

This is the same pattern as the manage preview integration ‚Äî import, add field, call Shell() where content is set.

**Back to `cmd/wf/list.go` ‚Äî ANSI coloring:** Use terminal-native ANSI escape codes (not lipgloss, since this is CLI output not TUI):

```go
const (
    ansiReset  = "\033[0m"
    ansiBold   = "\033[1m"
    ansiDim    = "\033[2m"
    ansiCyan   = "\033[36m"
    ansiGreen  = "\033[32m"
    ansiYellow = "\033[33m"
)
```

Update the output format in `runList`:
- Folder prefix (if workflow name contains "/"): dim cyan color
- Workflow name (after last "/"): bold (default terminal color)
- Description: dim
- Tags: yellow, in brackets

Check if stdout is a terminal before using colors (avoid ANSI in piped output):
```go
import "golang.org/x/term"
isTerminal := term.IsTerminal(int(os.Stdout.Fd()))
```
If not a terminal, skip ANSI codes and output plain text (current behavior).

Note: `golang.org/x/term` may already be an indirect dependency. If not, use `os.Getenv("TERM")` as a simpler heuristic, or just always output colors (most modern terminals support ANSI).

Actually, simpler approach that avoids new deps: use lipgloss for CLI output too. `lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Render(folder)` works in non-TUI contexts and handles NO_COLOR automatically. Use this approach:
```go
folderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("6"))   // cyan
nameStyle := lipgloss.NewStyle().Bold(true)
descStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("242"))   // dim
tagStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("3"))      // yellow
```

This approach uses lipgloss (already a dep) which handles NO_COLOR, TERM, and color capability detection automatically.
  </action>
  <verify>
```bash
go build ./... && go test ./internal/manage/... -v -count=1 && go test ./internal/picker/... -v -count=1 && go test ./cmd/wf/... -v -count=1

# Spot check wf list coloring
go run ./cmd/wf list 2>/dev/null | head -5
```
  </verify>
  <done>
  - Preview pane uses viewport with content-bounded scrolling (no blank overscroll)
  - Preview shows syntax-highlighted shell commands via highlight.Shell() in both manage and picker
  - Preview scroll indicator shows position when content exceeds viewport
  - J/K keybindings scroll preview without moving list cursor
  - Viewport resets to top when switching between workflows
  - Picker preview shows syntax-highlighted commands (updatePreview uses highlight.Shell)
  - wf list output uses ANSI colors for folder/name/description/tags separation
  - All tests pass, project compiles
  </done>
</task>

</tasks>

<verification>
```bash
# Full build
go build ./...

# Manage tests
go test ./internal/manage/... -v -count=1

# Picker tests
go test ./internal/picker/... -v -count=1

# CLI tests
go test ./cmd/wf/... -v -count=1

# Highlight tests (regression)
go test ./internal/highlight/... -v -count=1

# Full test suite
go test ./... -count=1
```
</verification>

<success_criteria>
- Sidebar filters instantly on cursor move (no Enter needed)
- Breadcrumb shows active folder/tag filter
- Empty state is context-aware
- Preview pane uses viewport with bounded scrolling
- Preview shows syntax-highlighted commands in both manage and picker
- Scroll indicator visible when content exceeds viewport
- wf list shows colored output (folder, name, tags)
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-terminal-compat/07-03-SUMMARY.md`
</output>
