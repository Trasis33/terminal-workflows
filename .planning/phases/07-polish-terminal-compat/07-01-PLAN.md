---
phase: 07-polish-terminal-compat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/highlight/highlight.go
  - internal/highlight/highlight_test.go
autonomous: true
requirements: [DISP-01, DISP-02]

must_haves:
  truths:
    - "Shell commands render with distinct colors for keywords, strings, variables, flags, pipes, redirects, and comments"
    - "Template parameters ({{name}}) render in a distinct accent color separate from shell syntax"
    - "Highlighting degrades gracefully to plain text if Chroma fails"
    - "Syntax highlighting colors match the active wf theme"
  artifacts:
    - path: "internal/highlight/highlight.go"
      provides: "Shell syntax highlighting with lipgloss token styling and template param handling"
      exports: ["Shell", "TokenStyles", "TokenStylesFromColors"]
    - path: "internal/highlight/highlight_test.go"
      provides: "Unit tests for highlighting with known token outputs"
      min_lines: 50
  key_links:
    - from: "internal/highlight/highlight.go"
      to: "chroma/v2/lexers"
      via: "lexers.Get('bash') + Coalesce"
      pattern: "lexers\\.Get.*bash"
    - from: "internal/highlight/highlight.go"
      to: "lipgloss"
      via: "style.Render(token.Value) per token"
      pattern: "Render.*token"
---

<objective>
Create the `internal/highlight` package that provides shell syntax highlighting using Chroma v2 lexer with direct lipgloss token styling.

Purpose: Foundation for syntax-highlighted command display in manage preview (DISP-01) and browse list preview (DISP-02). Uses direct token iteration (not Chroma's formatter) to keep colors in lipgloss, consistent with the rest of the TUI.

Output: `internal/highlight/` package with Shell() function, token style builder, and template parameter handling.
</objective>

<execution_context>
@/Users/fredriklanga/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/fredriklanga/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-terminal-compat/07-CONTEXT.md
@.planning/phases/07-polish-terminal-compat/07-RESEARCH.md
</context>

<interfaces>
<!-- Key types the executor needs. Extracted from codebase. -->

From internal/manage/theme.go:
```go
type themeColors struct {
    Primary    string `yaml:"primary"`    // Main accent (ANSI-256 code)
    Secondary  string `yaml:"secondary"`  // Secondary accent
    Tertiary   string `yaml:"tertiary"`   // Tertiary accent
    Text       string `yaml:"text"`       // Normal text
    Dim        string `yaml:"dim"`        // Dimmed/muted text
    Border     string `yaml:"border"`     // Border color
    Background string `yaml:"background"` // Background hint
}
```

From internal/manage/styles.go:
```go
type themeStyles struct {
    Sidebar, List, Preview, Selected, Highlight, Tag, Dim, Hint lipgloss.Style
    DialogBox, DialogTitle, FormTitle, ActiveBorder, InactiveBorder lipgloss.Style
}
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create highlight package with Shell() function and token styles</name>
  <files>internal/highlight/highlight.go, internal/highlight/highlight_test.go</files>
  <action>
**First**, add Chroma v2 dependency:
```bash
go get github.com/alecthomas/chroma/v2@latest
```

**Then create `internal/highlight/highlight.go`** with:

1. **`TokenStyles` type** — `map[chroma.TokenType]lipgloss.Style` used for styling tokens

2. **`TokenStylesFromColors(primary, secondary, tertiary, dim, text string) TokenStyles`** function that creates a token style map from ANSI-256 color codes (the same codes used in manage's Theme). Map token types as follows:
   - `chroma.Keyword`, `chroma.KeywordReserved` → primary color (bright accent for if/for/while/do/done/case)
   - `chroma.NameBuiltin` → secondary color (echo, cd, export, source, test)
   - `chroma.LiteralString`, `chroma.LiteralStringDouble`, `chroma.LiteralStringSingle`, `chroma.LiteralStringBacktick` → tertiary color
   - `chroma.Comment`, `chroma.CommentSingle` → dim color
   - `chroma.NameVariable` → secondary color (variable expansions like $VAR, ${VAR})
   - `chroma.Operator`, `chroma.Punctuation` → text color (pipes |, redirects >, semicolons)
   - `chroma.LiteralNumber` → tertiary color
   - `chroma.GenericError` → text color (fallback, don't highlight errors red)
   
   Build each lipgloss.Style using `lipgloss.NewStyle().Foreground(lipgloss.Color(colorCode))`.

3. **`Shell(command string, styles TokenStyles) string`** function:
   - Use `lexers.Get("bash")` and `chroma.Coalesce(lexer)` to get the coalesced bash lexer
   - Pre-process: find `{{paramname}}` patterns using regex `\{\{(\w+)(?::([^}]*))?\}\}`, replace each with a unique sentinel like `__WF_P0__`, `__WF_P1__` etc. Store mapping of sentinel → original `{{paramname}}` (or `{{paramname:default}}`) text.
   - Tokenise the sentinel-replaced command via `lexer.Tokenise(nil, preprocessed)`
   - Iterate tokens. For each token:
     - Check if token.Value contains a sentinel. If so, split around the sentinel, style non-sentinel parts normally, and render the original `{{paramname}}` text using primary color + bold (the accent color for template params).
     - Otherwise, find matching style: check `styles[token.Type]`, then walk `token.Type.Parent()` until a match. Fall back to unstyled if no match.
     - Append styled text to `strings.Builder`
   - Return builder string
   - If lexer is nil or Tokenise fails, return the original command string unchanged (graceful degradation)

4. **`ShellPlain(command string) string`** — ANSI-stripped version for width calculations. Uses the same lexer but returns plain text (or just returns the input since it's already plain). Actually this is simpler: just return the command as-is. This function exists so callers know they can get the unhighlighted version for width measurement.

**Then create `internal/highlight/highlight_test.go`** with tests:
- Test that `Shell()` returns non-empty string for a simple command like `echo "hello"`
- Test that `Shell()` returns the original command when given an empty styles map (graceful degradation)
- Test that template parameters `{{name}}` are not mangled (sentinel replacement + restoration works)
- Test that `TokenStylesFromColors` returns a non-empty map with expected token types
- Test that multi-line commands work (e.g., command with `\n`)
- Test that pipe commands work: `cat file.txt | grep pattern | sort`
  </action>
  <verify>
```bash
go build ./internal/highlight/... && go test ./internal/highlight/... -v -count=1
```
  </verify>
  <done>
  - `internal/highlight/highlight.go` exists with exported Shell(), TokenStyles, TokenStylesFromColors
  - `internal/highlight/highlight_test.go` passes all tests
  - Chroma v2 added to go.mod/go.sum
  - Shell() returns ANSI-styled text for shell commands
  - Template params {{name}} render with accent color, not as lexer errors
  - Graceful degradation: returns plain text on lexer failure
  </done>
</task>

</tasks>

<verification>
```bash
# Package builds
go build ./internal/highlight/...

# Tests pass
go test ./internal/highlight/... -v -count=1

# Full project still builds
go build ./...

# Verify chroma is in go.mod
grep "alecthomas/chroma/v2" go.mod
```
</verification>

<success_criteria>
- internal/highlight package compiles and exports Shell(), TokenStyles, TokenStylesFromColors
- All tests pass including template param handling
- Chroma v2 is properly added to go.mod
- Full project compiles (go build ./...)
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-terminal-compat/07-01-SUMMARY.md`
</output>
