---
phase: 05-ai-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - cmd/wf/generate.go
  - cmd/wf/autofill.go
  - cmd/wf/root.go
autonomous: true

must_haves:
  truths:
    - "User can run `wf generate 'description'` and get a pre-filled workflow creation prompt"
    - "User can run `wf generate` with no args and enter interactive mode with clarifying questions"
    - "User can run `wf autofill my-workflow --name --tags` to AI-fill specific fields"
    - "User can run `wf autofill my-workflow` with no flags to interactively choose fields"
    - "Running any AI command without Copilot CLI shows clear error with install instructions"
    - "Non-AI commands are completely unaffected by AI availability"
  artifacts:
    - path: "cmd/wf/generate.go"
      provides: "wf generate command with single-shot and interactive modes"
      min_lines: 80
    - path: "cmd/wf/autofill.go"
      provides: "wf autofill command with field flags"
      min_lines: 60
    - path: "cmd/wf/root.go"
      provides: "Updated root with generateCmd and autofillCmd registered"
      contains: "generateCmd"
  key_links:
    - from: "cmd/wf/generate.go"
      to: "internal/ai"
      via: "ai.GetGenerator for lazy init"
      pattern: "ai\\.GetGenerator"
    - from: "cmd/wf/generate.go"
      to: "internal/store"
      via: "saves generated workflow via store.Save"
      pattern: "getStore\\(\\)\\.Save"
    - from: "cmd/wf/autofill.go"
      to: "internal/ai"
      via: "ai.GetGenerator + Autofill call"
      pattern: "gen\\.Autofill"
    - from: "cmd/wf/autofill.go"
      to: "internal/store"
      via: "reads existing workflow, saves updated version"
      pattern: "getStore\\(\\)"
---

<objective>
Create the `wf generate` and `wf autofill` CLI commands with graceful degradation when the Copilot SDK is unavailable.

Purpose: These are the primary AI entry points — users generate workflows from natural language descriptions or auto-fill metadata for existing workflows. Both commands must show clear error messages when AI is unavailable while never affecting non-AI functionality.
Output: Two new cobra commands wired into root.go.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-integration/05-CONTEXT.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@.planning/phases/05-ai-integration/05-01-SUMMARY.md
@cmd/wf/root.go
@cmd/wf/add.go
@cmd/wf/register.go
@internal/ai/generator.go
@internal/ai/availability.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: wf generate command (single-shot + interactive)</name>
  <files>cmd/wf/generate.go</files>
  <action>
    Create `cmd/wf/generate.go` with cobra command:

    ```
    var generateCmd = &cobra.Command{
        Use:   "generate [description]",
        Short: "Generate a workflow from a natural language description",
        Long:  `Uses AI to create a workflow from your description. Requires GitHub Copilot CLI.

    Without arguments, enters interactive mode where you describe what you want
    and answer clarifying questions. With a description argument, generates directly.

    Examples:
      wf generate "deploy to kubernetes with rollback"
      wf generate "git squash last N commits"
      wf generate    (interactive mode)`,
        RunE: runGenerate,
    }
    ```

    Add flags in init():
    - `--tag, -t` ([]string): suggested tags
    - `--folder, -f` (string): target folder
    - `--shell, -s` (string): target shell (bash/zsh/fish)

    Implement `runGenerate(cmd *cobra.Command, args []string) error`:
    1. Call `ai.GetGenerator(cmd.Context())` — if err != nil, print error to stderr and `return nil` (exit 0, not error — keeps non-AI features unaffected)
    2. If `len(args) > 0`: single-shot mode — join args as description
    3. If no args: interactive mode — call `runInteractiveGenerate(scanner, gen, ctx)`
    4. Build `ai.GenerateRequest` with description + flags
    5. Print "Generating workflow..." to stderr
    6. Call `gen.Generate(ctx, req)` — on error, print to stderr, offer retry
    7. On success, present result as pre-filled inline prompts:
       - Show generated values: name, command (multiline-safe), description, tags
       - For each field, show current value and let user edit inline (scanner-based, press Enter to accept):
         `Name [deploy-staging]: ` — user can type new name or press Enter to keep
         `Command [kubectl rollout ...]: ` — show, let user edit (or 'multi' for multiline editor)
         `Description [Deploy to staging]: ` — edit or accept
         `Tags [deploy, kubernetes]: ` — edit or accept
       - This reuses the pattern from add.go/register.go but with pre-filled defaults
    8. After user confirms/edits, build store.Workflow, extract params via template.ExtractParams, save via getStore().Save()
    9. Print "Created {name}"

    Implement `runInteractiveGenerate(scanner, gen, ctx)`:
    1. Ask: `"What would you like to automate? "` — read description
    2. Ask: `"Target shell (bash/zsh/fish, or press Enter to skip): "`
    3. Ask: `"Any tags? (comma-separated, or press Enter to skip): "`
    4. Build GenerateRequest, call gen.Generate
    5. Continue with same pre-fill edit flow as single-shot

    Implement `func presentAndSave(result *ai.GenerateResult, scanner *bufio.Scanner) error`:
    - Shared function used by both modes
    - Shows each field with AI value as default
    - Lets user edit inline (Enter = accept default)
    - Supports "regenerate" — if user types "!regen" or "!r" at any prompt, return to caller to regenerate
    - After all fields confirmed, save workflow

    IMPORTANT: When showing command with newlines, display it properly. Use `"multi"` input if command contains newlines.

    IMPORTANT: Don't `return err` from RunE when it's an AI availability error — use `fmt.Fprintf(os.Stderr, ...)` and `return nil`. This prevents cobra from showing usage help on AI failures.
  </action>
  <verify>
    `go build ./cmd/wf/...` compiles.
    `go vet ./cmd/wf/...` passes.
    `./wf generate --help` shows usage with description, flags, and examples.
    Without Copilot CLI installed: `./wf generate "test"` prints error to stderr with install hint, exits 0.
  </verify>
  <done>
    `wf generate "description"` calls AI, presents result in pre-filled edit prompts, saves on confirm.
    `wf generate` (no args) enters interactive mode with questions.
    AI unavailable → clear error message to stderr, exit 0, no crash.
    Flags --tag, --folder, --shell pass context to AI.
    Generated workflow saved with extracted template parameters.
  </done>
</task>

<task type="auto">
  <name>Task 2: wf autofill command + root.go wiring</name>
  <files>
    cmd/wf/autofill.go
    cmd/wf/root.go
  </files>
  <action>
    Create `cmd/wf/autofill.go` with cobra command:

    ```
    var autofillCmd = &cobra.Command{
        Use:   "autofill [workflow-name]",
        Short: "Auto-fill workflow metadata using AI",
        Long:  `Uses AI to generate metadata (name, description, tags, argument types) for an existing workflow.

    Specify which fields to fill with flags, or run without flags to choose interactively.

    Examples:
      wf autofill my-workflow --description --tags
      wf autofill my-workflow --name --tags --args
      wf autofill my-workflow    (choose fields interactively)`,
        Args: cobra.ExactArgs(1),
        RunE: runAutofill,
    }
    ```

    Add flags in init():
    - `--name` (bool): fill name field
    - `--description` (bool): fill description field
    - `--tags` (bool): fill tags field
    - `--args` (bool): fill argument descriptions and types
    - `--all` (bool): fill all fields

    Implement `runAutofill(cmd *cobra.Command, args []string) error`:
    1. Get workflow by name from store: `s := getStore(); wf, err := s.Get(args[0])`
    2. Call `ai.GetGenerator(cmd.Context())` — if err != nil, print to stderr, return nil
    3. Determine which fields to fill:
       - If `--all` flag: fields = ["name", "description", "tags", "args"]
       - If specific flags provided: build fields list from flags
       - If no flags: interactive — list available fields, ask user to pick (numbered list + comma-separated selection)
    4. Build `ai.AutofillRequest{Workflow: wf, Fields: fields}`
    5. Print "Auto-filling metadata..." to stderr
    6. Call `gen.Autofill(ctx, req)` — on error, print to stderr
    7. Present results with inline edit prompts:
       - For each filled field, show current → AI suggestion:
         `Name: "my-cmd" → "docker-container-restart" [accept/edit/skip]: `
       - User can type "y" or Enter to accept, type new value to edit, or "s" to skip
       - For tags: show as comma-separated, same accept/edit/skip
       - For args: show table of arg names with AI-suggested descriptions and types
    8. Apply accepted changes to the workflow
    9. Save updated workflow via `s.Save(wf)`
    10. Print "Updated {name}" with summary of changed fields

    IMPORTANT: Autofill must NOT change the command field — it only fills metadata.
    IMPORTANT: If workflow has no command (empty), warn user and suggest using `wf generate` instead.

    Update `cmd/wf/root.go`:
    - Add `rootCmd.AddCommand(generateCmd)` and `rootCmd.AddCommand(autofillCmd)` in init()
    - Keep all existing commands unchanged
  </action>
  <verify>
    `go build ./cmd/wf/...` compiles.
    `go vet ./cmd/wf/...` passes.
    `./wf --help` shows generate and autofill in command list.
    `./wf autofill --help` shows usage with field flags.
    `./wf generate --help` shows usage with examples.
    Without Copilot CLI: `./wf autofill test-workflow` prints error to stderr, exits 0.
    `./wf list` still works normally (non-AI features unaffected).
  </verify>
  <done>
    `wf autofill my-workflow --description --tags` calls AI for specified fields, shows diff, saves.
    `wf autofill my-workflow` (no flags) enters interactive field selection.
    `--all` flag fills all metadata fields at once.
    Results shown as current → suggestion with accept/edit/skip per field.
    AI unavailable → clear error, exit 0, no crash.
    Both generateCmd and autofillCmd registered in root.go init().
    All existing commands still work — `wf list`, `wf add`, etc. unaffected.
  </done>
</task>

</tasks>

<verification>
- `go build ./cmd/wf/...` — project compiles with new commands
- `go vet ./cmd/wf/...` — no issues
- `./wf --help` — shows generate and autofill commands
- Without Copilot CLI installed:
  - `./wf generate "test"` → prints error to stderr, exits 0
  - `./wf autofill some-workflow` → prints error to stderr, exits 0
  - `./wf list` → works normally
  - `./wf add` → works normally
- AI commands visible in help even without SDK
</verification>

<success_criteria>
- `wf generate` supports single-shot (args) and interactive (no args) modes
- `wf autofill` supports field flags, --all, and interactive field selection
- AI results presented as pre-filled edit prompts (not preview-then-decide)
- Graceful degradation: clear error message, exit 0, non-AI features unaffected
- Both commands registered in root.go
- Generated workflows saved with auto-extracted template parameters
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-02-SUMMARY.md`
</output>
