---
phase: 05-ai-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/manage/ai_actions.go
  - internal/manage/model.go
  - internal/manage/browse.go
  - internal/manage/keys.go
  - internal/manage/form.go
autonomous: false

must_haves:
  truths:
    - "User can press a key in browse view to generate a new workflow via AI"
    - "User can press a key on a selected workflow to auto-fill its metadata via AI"
    - "TUI shows spinner/loading state while AI request is in progress"
    - "AI result pre-fills the existing create/edit form — no separate preview"
    - "Selecting AI action without Copilot CLI shows inline error toast, doesn't crash"
    - "AI actions are visible in hints bar regardless of SDK availability"
  artifacts:
    - path: "internal/manage/ai_actions.go"
      provides: "AI tea.Cmd functions and message types for TUI integration"
      min_lines: 50
    - path: "internal/manage/model.go"
      provides: "Updated root model handling AI messages"
      contains: "aiResultMsg"
    - path: "internal/manage/browse.go"
      provides: "AI keybindings in browse view"
      contains: "generateAI"
    - path: "internal/manage/keys.go"
      provides: "AI keybindings added to keyMap"
      contains: "GenerateAI"
  key_links:
    - from: "internal/manage/ai_actions.go"
      to: "internal/ai"
      via: "ai.GetGenerator + Generate/Autofill calls"
      pattern: "ai\\.GetGenerator"
    - from: "internal/manage/model.go"
      to: "internal/manage/ai_actions.go"
      via: "handles aiResultMsg and aiErrorMsg"
      pattern: "case aiResultMsg"
    - from: "internal/manage/model.go"
      to: "internal/manage/form.go"
      via: "pre-fills FormModel with AI result"
      pattern: "NewFormModel.*ai"
    - from: "internal/manage/browse.go"
      to: "internal/manage/ai_actions.go"
      via: "triggers AI commands via keybindings"
      pattern: "generateWorkflowCmd\\|autofillWorkflowCmd"
---

<objective>
Integrate AI generate and autofill actions into the management TUI (wf manage). Users can trigger AI generation from the browse view and auto-fill metadata on any selected workflow.

Purpose: The TUI is the second major entry point for AI features (alongside CLI commands). AI actions run asynchronously via tea.Cmd to never block the event loop. Results pre-fill the existing huh form.
Output: AI-integrated management TUI with keybindings, spinner, async execution, and pre-filled forms.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-integration/05-CONTEXT.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@.planning/phases/05-ai-integration/05-01-SUMMARY.md
@internal/manage/model.go
@internal/manage/browse.go
@internal/manage/form.go
@internal/manage/keys.go
@internal/manage/manage.go
@internal/ai/generator.go
@internal/ai/availability.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: AI action messages, async commands, and keybindings</name>
  <files>
    internal/manage/ai_actions.go
    internal/manage/keys.go
    internal/manage/browse.go
  </files>
  <action>
    Create `internal/manage/ai_actions.go`:
    - Define message types:
      ```go
      type aiGenerateResultMsg struct {
          result *ai.GenerateResult
          err    error
      }
      type aiAutofillResultMsg struct {
          result   *ai.AutofillResult
          workflow store.Workflow // the original workflow being autofilled
          err      error
      }
      type aiErrorMsg struct {
          err error
      }
      type aiLoadingMsg struct {
          task string // "generate" or "autofill"
      }
      ```
    - Define async tea.Cmd functions:
      ```go
      func generateWorkflowCmd(description string) tea.Cmd {
          return func() tea.Msg {
              ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
              defer cancel()
              gen, err := ai.GetGenerator(ctx)
              if err != nil {
                  return aiGenerateResultMsg{err: err}
              }
              req := ai.GenerateRequest{Description: description}
              result, err := gen.Generate(ctx, req)
              return aiGenerateResultMsg{result: result, err: err}
          }
      }
      func autofillWorkflowCmd(wf store.Workflow, fields []string) tea.Cmd {
          return func() tea.Msg {
              ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
              defer cancel()
              gen, err := ai.GetGenerator(ctx)
              if err != nil {
                  return aiAutofillResultMsg{err: err, workflow: wf}
              }
              req := ai.AutofillRequest{Workflow: &wf, Fields: fields}
              result, err := gen.Autofill(ctx, req)
              return aiAutofillResultMsg{result: result, workflow: wf, err: err}
          }
      }
      ```
    - IMPORTANT: These run in goroutines via tea.Cmd — they must NOT access any Model fields. Pass all needed data as function parameters.

    Update `internal/manage/keys.go`:
    - Add to keyMap struct:
      ```go
      GenerateAI key.Binding
      AutofillAI key.Binding
      ```
    - Add to defaultKeyMap():
      ```go
      GenerateAI: key.NewBinding(key.WithKeys("G"), key.WithHelp("G", "AI generate")),
      AutofillAI: key.NewBinding(key.WithKeys("A"), key.WithHelp("A", "AI autofill")),
      ```
    - Add to FullHelp() — add a new row: `{k.GenerateAI, k.AutofillAI}`

    Update `internal/manage/browse.go`:
    - Add AI keybindings to `updateListFocus`:
      ```go
      case "G":
          // AI Generate: prompt for description via a simple dialog, then run AI
          return b, func() tea.Msg { return showAIGenerateDialogMsg{} }
      case "A":
          if len(b.filtered) > 0 {
              wf := b.filtered[b.cursor]
              return b, func() tea.Msg { return showAIAutofillDialogMsg{workflow: wf} }
          }
          return b, nil
      ```
    - Update renderHints to include AI keys:
      Change list focus hints to: `"n new  e edit  d delete  m move  G AI generate  A AI autofill  / search  tab folders/tags  ←/h sidebar  S settings  q quit"`

    Define message types for dialog triggers in ai_actions.go:
    ```go
    type showAIGenerateDialogMsg struct{}
    type showAIAutofillDialogMsg struct{ workflow store.Workflow }
    ```
  </action>
  <verify>
    `go build ./internal/manage/...` compiles.
    `go vet ./internal/manage/...` passes.
  </verify>
  <done>
    AI message types defined for async result handling.
    Async tea.Cmd functions call ai.GetGenerator and run AI operations in goroutines.
    G and A keybindings added to browse view.
    AI keybindings visible in hints bar.
    FullHelp includes AI keybindings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Model message handling, AI dialogs, form pre-fill, and loading state</name>
  <files>
    internal/manage/model.go
    internal/manage/ai_actions.go
    internal/manage/form.go
  </files>
  <action>
    Update `internal/manage/model.go` Update() to handle AI messages:

    Add cases in the switch statement (after existing message handlers):

    ```go
    case showAIGenerateDialogMsg:
        // Show a simple text input dialog asking for description
        dlg := NewAIGenerateDialog(m.theme)
        m.dialog = &dlg
        return m, dlg.Init()

    case showAIAutofillDialogMsg:
        // Quick check: is AI available? If not, show error inline
        if !ai.IsAvailable() {
            // Show error as a brief status message (reuse dialog or set error state)
            m.browse.aiError = ai.ErrUnavailable.Error()
            return m, nil
        }
        // Autofill all fields for the selected workflow
        wf := msg.workflow
        m.aiLoading = true
        m.aiLoadingTask = "autofill"
        return m, autofillWorkflowCmd(wf, []string{"name", "description", "tags", "args"})

    case aiGenerateResultMsg:
        m.aiLoading = false
        if msg.err != nil {
            m.browse.aiError = msg.err.Error()
            return m, nil
        }
        // Pre-fill create form with AI result
        m.prevState = m.state
        m.state = viewCreate
        folders := extractFolders(m.workflows)
        tags := extractTags(m.workflows)
        // Build a Workflow from the AI result to pre-fill
        aiWf := &store.Workflow{
            Name:        msg.result.Name,
            Command:     msg.result.Command,
            Description: msg.result.Description,
            Tags:        msg.result.Tags,
            Args:        msg.result.Args,
        }
        m.form = NewFormModel("create", aiWf, m.store, tags, folders, m.theme)
        m.form.SetDimensions(m.width, m.height)
        return m, m.form.Init()

    case aiAutofillResultMsg:
        m.aiLoading = false
        if msg.err != nil {
            m.browse.aiError = msg.err.Error()
            return m, nil
        }
        // Merge AI result into original workflow, open edit form
        wf := msg.workflow
        if msg.result.Name != nil {
            wf.Name = *msg.result.Name
        }
        if msg.result.Description != nil {
            wf.Description = *msg.result.Description
        }
        if msg.result.Tags != nil {
            wf.Tags = msg.result.Tags
        }
        if msg.result.Args != nil {
            wf.Args = msg.result.Args
        }
        m.prevState = m.state
        m.state = viewEdit
        folders := extractFolders(m.workflows)
        tags := extractTags(m.workflows)
        m.form = NewFormModel("edit", &wf, m.store, tags, folders, m.theme)
        m.form.SetDimensions(m.width, m.height)
        return m, m.form.Init()
    ```

    Add fields to Model struct:
    ```go
    aiLoading     bool   // true while AI request is in progress
    aiLoadingTask string // "generate" or "autofill"
    ```

    Add field to BrowseModel struct:
    ```go
    aiError string // transient error message for AI failures, cleared on next key press
    ```

    In BrowseModel.Update(), clear aiError on any key press:
    ```go
    case tea.KeyMsg:
        b.aiError = "" // clear transient error
    ```

    In BrowseModel.renderHints(), if aiError is set, show it instead of normal hints:
    ```go
    if b.aiError != "" {
        return s.Error.Render("  ⚠ " + b.aiError)
    }
    ```
    (If themeStyles doesn't have Error style, create one using lipgloss.Color("196") — red foreground)

    Add `NewAIGenerateDialog` to `ai_actions.go`:
    - Creates a DialogModel with a single text input for "Describe what you want to automate"
    - On confirm: returns a `dialogResultMsg` with dtype `dialogAIGenerate` and data["description"]
    - Add `dialogAIGenerate` to the dialog type constants in dialog.go

    Handle `dialogAIGenerate` result in model.go `handleDialogResult`:
    ```go
    case dialogAIGenerate:
        description := msg.data["description"]
        if description == "" {
            return m, nil
        }
        if !ai.IsAvailable() {
            m.browse.aiError = ai.ErrUnavailable.Error()
            return m, nil
        }
        m.aiLoading = true
        m.aiLoadingTask = "generate"
        return m, generateWorkflowCmd(description)
    ```

    Update `internal/manage/form.go` NewFormModel to handle pre-fill for "create" mode:
    - Currently, create mode ignores the `wf` parameter. Change it:
      ```go
      if mode == "create" && wf != nil {
          // Pre-fill from AI result (or any provided workflow)
          m.vals.name = wf.Name
          m.vals.command = wf.Command
          m.vals.description = wf.Description
          m.vals.tagInput = strings.Join(wf.Tags, ", ")
      }
      ```
    - This small change enables AI pre-fill without any new form code.

    Update Model.View() to show loading indicator when aiLoading is true:
    ```go
    if m.aiLoading {
        spinner := "⣾ Generating with AI..."  // or "⣾ Auto-filling..."
        if m.aiLoadingTask == "autofill" {
            spinner = "⣾ Auto-filling metadata..."
        }
        loadingView := lipgloss.Place(m.width, m.height,
            lipgloss.Center, lipgloss.Center,
            lipgloss.NewStyle().Foreground(lipgloss.Color("49")).Render(spinner),
        )
        return loadingView
    }
    ```
    (Note: For a proper animated spinner, we'd need a tick command. A static message is acceptable for v1 — the AI call takes 2-15s. If time permits, add a spinner Bubble from charmbracelet/bubbles.)

    IMPORTANT: Import `"github.com/fredriklanga/wf/internal/ai"` in model.go and ai_actions.go. This is fine — manage already imports store and config.

    IMPORTANT: Don't modify dialog.go's existing dialog types. Add the new `dialogAIGenerate` constant alongside existing ones. The dialog system already supports custom types via the `dialogType` enum.
  </action>
  <verify>
    `go build ./internal/manage/...` compiles.
    `go build ./cmd/wf/...` compiles.
    `go vet ./...` passes.
    `go test ./internal/manage/... -v` — existing tests still pass.
  </verify>
  <done>
    AI generate dialog prompts for description, triggers async generation.
    AI autofill triggers async autofill for all fields on selected workflow.
    AI loading state shown with centered message during request.
    Generate result pre-fills create form (form opens with AI values).
    Autofill result merges into workflow, opens edit form.
    AI errors shown as transient message in hints bar (cleared on next keypress).
    SDK unavailable → inline error toast, no crash, TUI stays functional.
    Existing manage tests still pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete AI integration in both CLI and TUI:
    1. `wf generate` command (single-shot + interactive)
    2. `wf autofill` command (field flags + interactive)
    3. TUI AI actions (G for generate, A for autofill) with async execution and form pre-fill
    4. Graceful degradation when Copilot CLI is unavailable
  </what-built>
  <how-to-verify>
    1. Run `wf --help` — verify "generate" and "autofill" appear in command list
    2. Run `wf generate --help` — verify usage shows single-shot and interactive examples
    3. Run `wf autofill --help` — verify field flags shown (--name, --description, --tags, --args, --all)
    4. Run `wf generate "test"` without Copilot CLI installed — verify it prints clear error with install hint to stderr and exits 0 (not error)
    5. Run `wf autofill some-workflow` without Copilot CLI — verify same graceful error
    6. Run `wf list` — verify non-AI commands still work perfectly
    7. Run `wf manage` — verify G and A keys appear in hints bar
    8. In TUI, press G — verify description input dialog appears
    9. In TUI, press A on a workflow — verify graceful error message (if no SDK) appears briefly in hints bar
    10. Verify no startup delay — AI is lazily initialized only when AI commands are used

    If Copilot CLI IS installed (optional):
    11. Run `wf generate "docker build and push to registry"` — verify workflow generated, pre-filled prompts shown
    12. Run `wf autofill <existing-workflow> --description --tags` — verify metadata suggested
    13. In TUI, G → describe → verify form opens pre-filled with AI result
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `go build ./...` — entire project compiles
- `go test ./... -v` — all tests pass
- `go vet ./...` — no issues
- `wf --help` shows generate and autofill commands
- Graceful degradation: AI commands fail gracefully, non-AI commands unaffected
- TUI: G and A keybindings work, async execution with loading state
- Form pre-fill works for both AI generate (create form) and AI autofill (edit form)
</verification>

<success_criteria>
- TUI browse view has G (AI generate) and A (AI autofill) keybindings
- Pressing G opens description dialog → triggers async generation → pre-fills create form
- Pressing A on workflow → triggers async autofill → opens edit form with AI metadata
- Loading state shown during AI requests
- AI errors shown as transient inline messages
- SDK unavailable → error toast in TUI, doesn't crash or freeze
- All existing TUI functionality (browse, edit, create, delete, settings) still works
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-03-SUMMARY.md`
</output>
