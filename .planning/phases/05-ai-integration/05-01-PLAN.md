---
phase: 05-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/ai/generator.go
  - internal/ai/availability.go
  - internal/ai/prompts.go
  - internal/ai/models.go
  - internal/ai/copilot.go
  - internal/ai/copilot_test.go
  - internal/config/config.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Generator interface abstracts AI operations for testability"
    - "Availability detection lazily checks for Copilot CLI binary"
    - "ErrUnavailable provides clear install instructions"
    - "Model config reads from config.yaml with per-task overrides and fallback defaults"
    - "CopilotGenerator uses SDK to create sessions and parse JSON responses"
  artifacts:
    - path: "internal/ai/generator.go"
      provides: "Generator interface, request/result types"
      exports: ["Generator", "GenerateRequest", "GenerateResult", "AutofillRequest", "AutofillResult"]
    - path: "internal/ai/availability.go"
      provides: "Lazy availability detection + singleton initialization"
      exports: ["GetGenerator", "ErrUnavailable", "IsAvailable"]
    - path: "internal/ai/prompts.go"
      provides: "System prompts for generate and autofill operations"
      contains: "generateSystemPrompt"
    - path: "internal/ai/models.go"
      provides: "Model configuration types and defaults"
      exports: ["ModelConfig", "DefaultModelConfig"]
    - path: "internal/ai/copilot.go"
      provides: "CopilotGenerator implementation using SDK"
      exports: ["CopilotGenerator"]
    - path: "internal/ai/copilot_test.go"
      provides: "Tests with mock generator"
    - path: "internal/config/config.go"
      provides: "Extended config with AI model settings"
      exports: ["AIConfig", "LoadConfig"]
  key_links:
    - from: "internal/ai/copilot.go"
      to: "github.com/github/copilot-sdk/go"
      via: "SDK client integration"
      pattern: "copilot\\.NewClient"
    - from: "internal/ai/availability.go"
      to: "internal/ai/copilot.go"
      via: "lazy singleton initialization"
      pattern: "sync\\.Once"
    - from: "internal/ai/copilot.go"
      to: "internal/ai/models.go"
      via: "model selection per task"
      pattern: "modelFor"
    - from: "internal/ai/copilot.go"
      to: "internal/config/config.go"
      via: "reads AI config for model names"
      pattern: "config\\.LoadConfig"
---

<objective>
Create the `internal/ai/` package with Generator interface, Copilot SDK integration, availability detection, prompt templates, and model configuration. Extend the config package to support AI model settings from `config.yaml`.

Purpose: This is the foundational AI layer that all CLI commands and TUI actions will use. The interface pattern enables testability via mock generators.
Output: Complete `internal/ai/` package + config extension. CLI/TUI plans depend on this.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-integration/05-CONTEXT.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@internal/store/store.go
@internal/store/workflow.go
@internal/config/config.go
@cmd/wf/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generator interface, types, availability, and config extension</name>
  <files>
    internal/ai/generator.go
    internal/ai/availability.go
    internal/ai/models.go
    internal/config/config.go
  </files>
  <action>
    Create `internal/ai/generator.go`:
    - Define `GenerateRequest` struct with fields: Description (string), Tags ([]string), Folder (string), Shell (string)
    - Define `GenerateResult` struct with JSON tags: Name, Command, Description (strings), Tags ([]string), Args ([]store.Arg)
    - Define `AutofillRequest` struct: Workflow (*store.Workflow), Fields ([]string — which fields to fill)
    - Define `AutofillResult` struct with pointer fields for optional JSON: Name (*string), Description (*string), Tags ([]string), Args ([]store.Arg)
    - Define `Generator` interface with methods:
      - `Generate(ctx context.Context, req GenerateRequest) (*GenerateResult, error)`
      - `Autofill(ctx context.Context, req AutofillRequest) (*AutofillResult, error)`
      - `Available() bool`
      - `Close() error`

    Create `internal/ai/availability.go`:
    - Define `var ErrUnavailable = fmt.Errorf("AI features require GitHub Copilot CLI. Install with: gh extension install github/gh-copilot")`
    - Define `IsAvailable() bool` that calls `exec.LookPath("copilot")` — returns true if found, false otherwise. This is the fast check used by TUI to decide whether to show errors.
    - Define `GetGenerator(ctx context.Context) (Generator, error)` using `sync.Once` pattern:
      1. Check `exec.LookPath("copilot")` — if not found, set `initErr = ErrUnavailable`
      2. Load AI config via `config.LoadConfig()` to get model names
      3. Create `copilot.NewClient(&copilot.ClientOptions{LogLevel: "error"})`
      4. Call `client.Start(ctx)` — on error, set `initErr` with descriptive message
      5. Store `instance = &CopilotGenerator{client: client, config: modelCfg}`
      6. Return (instance, initErr)
    - Also provide `ResetGenerator()` for testing (resets sync.Once)

    Create `internal/ai/models.go`:
    - Define `ModelConfig` struct with yaml tags: Generate, Autofill, Fallback (all string, omitempty)
    - Define `DefaultModelConfig()` returning sensible defaults: Generate="gpt-4o", Autofill="gpt-4o-mini", Fallback="gpt-4o-mini"
    - Define `func (c ModelConfig) ForTask(task string) string` that returns the model for a given task name, falling back to Fallback, then to DefaultModelConfig().Fallback

    Extend `internal/config/config.go`:
    - Add `AIConfig` struct: `Models ModelConfig` (yaml:"models"), `Timeout int` (yaml:"timeout,omitempty" — default 30)
    - Add `Config` struct: `AI AIConfig` (yaml:"ai,omitempty")
    - Add `LoadConfig() (*Config, error)` that reads `~/.config/wf/config.yaml` via `goccy/go-yaml`. If file doesn't exist, return default config (not an error). If file exists but is malformed, return error.
    - Add `ConfigPath() string` returning the config.yaml path
    - Keep all existing functions (ConfigDir, WorkflowsDir, EnsureDir) unchanged.

    Import the ai models package from config: `import "github.com/fredriklanga/wf/internal/ai"` — WAIT, this creates a circular dependency. Instead, define ModelConfig in config package OR define a plain struct in config and have ai package import it.

    IMPORTANT: To avoid circular imports, define the AI config types in the config package:
    - `config.AIModelConfig` struct (Generate, Autofill, Fallback strings)
    - `config.AISettings` struct (Models AIModelConfig, Timeout int)
    - `config.AppConfig` struct (AI AISettings)
    - `config.LoadAppConfig() (*AppConfig, error)`
    - Then `internal/ai/models.go` imports config and wraps it.

    Actually, the cleanest approach: define ModelConfig in `internal/ai/models.go` as a standalone type. Config loading in `internal/config/config.go` returns a generic struct with an `AI` field that has `Models` map or struct. The ai package calls config.LoadAppConfig() and maps the result. No circular import.

    Final approach — keep it simple:
    - `config.go` adds: `type AppConfig struct { AI struct { Models struct { Generate, Autofill, Fallback string } `yaml:"models"` ; Timeout int `yaml:"timeout"` } `yaml:"ai"` }`
    - `config.LoadAppConfig()` reads config.yaml, returns *AppConfig with defaults
    - `ai/models.go` imports config, calls LoadAppConfig(), extracts model names
    - No circular dependency since ai imports config (one-way)
  </action>
  <verify>
    `go build ./internal/ai/...` compiles without errors.
    `go build ./internal/config/...` compiles without errors.
    `go vet ./internal/ai/... ./internal/config/...` passes.
  </verify>
  <done>
    Generator interface defined with Generate, Autofill, Available, Close methods.
    Request/Result types have proper JSON tags for AI response parsing.
    ErrUnavailable has clear install instructions.
    GetGenerator uses sync.Once lazy init with LookPath check.
    ModelConfig supports per-task model selection with fallback.
    config.LoadAppConfig reads config.yaml or returns defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: CopilotGenerator implementation, prompts, and tests</name>
  <files>
    internal/ai/copilot.go
    internal/ai/prompts.go
    internal/ai/copilot_test.go
    go.mod
    go.sum
  </files>
  <action>
    Run `go get github.com/github/copilot-sdk/go` to add the SDK dependency.

    Create `internal/ai/prompts.go`:
    - Define `const generateSystemPrompt` — the system prompt for workflow generation. Use the exact prompt from RESEARCH.md (rules for JSON-only output, {{parameter}} syntax, examples with deploy-staging and git-squash).
    - Define `const autofillSystemPrompt` — the system prompt for metadata generation. Use the exact prompt from RESEARCH.md.
    - Define `func buildGeneratePrompt(req GenerateRequest) string` that builds the user message from the request. Include description, and optionally mention target shell, tags, folder if provided. Example output: `"Generate a workflow for: deploy to staging with rollback\nTarget shell: bash\nSuggested tags: deploy, kubernetes"`
    - Define `func buildAutofillPrompt(req AutofillRequest) string` that builds the user message. Include the existing command, any existing metadata, and which fields to fill. Example: `"Workflow command: docker run -p {{port}}:80 {{image}}\nExisting name: docker-run\nFill these fields: description, tags, args"`

    Create `internal/ai/copilot.go`:
    - Define `CopilotGenerator` struct with fields: `client` (copilot client), `config` (model config from LoadAppConfig), `timeout` (time.Duration, default 30s)
    - Implement `Generate(ctx context.Context, req GenerateRequest) (*GenerateResult, error)`:
      1. Create timeout context: `ctx, cancel := context.WithTimeout(ctx, g.timeout); defer cancel()`
      2. Create session: `g.client.CreateSession(ctx, &copilot.SessionConfig{Model: g.modelFor("generate"), SystemMessage: &copilot.SystemMessageConfig{Content: generateSystemPrompt}})`
      3. `defer session.Destroy()`
      4. Build prompt with `buildGeneratePrompt(req)`
      5. Call `session.SendAndWait(ctx, copilot.MessageOptions{Prompt: prompt})`
      6. Check for nil result / nil content
      7. Parse JSON response into GenerateResult via `json.Unmarshal`
      8. If JSON parse fails, try to extract JSON from markdown code fences (fallback: strip ```json...``` wrapper)
      9. Return result
    - Implement `Autofill(ctx context.Context, req AutofillRequest) (*AutofillResult, error)`:
      Same pattern as Generate but uses autofillSystemPrompt and autofill model.
    - Implement `Available() bool` — returns true (if CopilotGenerator exists, it was successfully initialized)
    - Implement `Close() error` — calls `g.client.Stop()`
    - Implement `func (g *CopilotGenerator) modelFor(task string) string` — reads from config, falls back to defaults.

    IMPORTANT: The SDK API may differ slightly from research. If `SendAndWait` is not available, use `Send` with event-based `On` handler that collects the response. Check the SDK Go README at implementation time. If the API shape differs, adapt — the interface stays the same.

    IMPORTANT: If `copilot.SessionConfig`, `copilot.SystemMessageConfig`, or `copilot.MessageOptions` have different field names, adapt to match the actual SDK types. The research has MEDIUM confidence on exact Go struct fields.

    Create `internal/ai/copilot_test.go`:
    - Define `mockGenerator` struct implementing Generator interface with canned responses.
    - Test `TestMockGenerate`: mock returns a valid GenerateResult, verify all fields.
    - Test `TestMockAutofill`: mock returns an AutofillResult with only requested fields.
    - Test `TestMockUnavailable`: mock returns ErrUnavailable, verify error message.
    - Test `TestBuildGeneratePrompt`: verify prompt includes description, optional shell/tags.
    - Test `TestBuildAutofillPrompt`: verify prompt includes command, existing metadata, requested fields.
    - Do NOT test actual SDK calls (requires Copilot CLI installed).

    After creating files, run `go mod tidy` to clean up dependencies.
  </action>
  <verify>
    `go build ./internal/ai/...` compiles.
    `go test ./internal/ai/... -v` — all tests pass.
    `go vet ./internal/ai/...` passes.
    `go mod tidy` exits cleanly.
  </verify>
  <done>
    CopilotGenerator implements Generator interface with Copilot SDK.
    System prompts enforce JSON-only output with examples.
    Prompt builders include all request context.
    JSON response parsing handles both clean JSON and markdown-wrapped JSON.
    Mock-based tests verify interface contract, prompt building, and error handling.
    SDK dependency added to go.mod.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` — entire project compiles with new ai package
- `go test ./internal/ai/... -v` — all tests pass
- `go vet ./...` — no issues
- `internal/ai/generator.go` exports Generator interface with 4 methods
- `internal/ai/availability.go` exports GetGenerator with lazy init
- `internal/ai/copilot.go` uses Copilot SDK for implementation
- `internal/config/config.go` supports config.yaml AI settings
</verification>

<success_criteria>
- Generator interface is defined and testable via mock
- CopilotGenerator implementation compiles against Copilot SDK
- Availability detection uses exec.LookPath("copilot") lazily
- ErrUnavailable has clear, actionable install instructions
- Model config supports per-task overrides with fallback defaults
- Config.yaml loading works (returns defaults if file missing)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-01-SUMMARY.md`
</output>
