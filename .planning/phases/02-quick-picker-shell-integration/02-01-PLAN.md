---
phase: 02-quick-picker-shell-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/picker/search.go
  - internal/picker/search_test.go
autonomous: true

must_haves:
  truths:
    - "Fuzzy search returns workflows matching by name, description, or tags"
    - "Tag filter with @tag prefix narrows results before fuzzy matching"
    - "Empty query returns all workflows (bypasses fuzzy)"
    - "Search results include MatchedIndexes for character highlighting"
  artifacts:
    - path: "internal/picker/search.go"
      provides: "Search function, tag filter parsing, fuzzy Source interface"
      exports: ["Search", "ParseQuery", "WorkflowSource"]
    - path: "internal/picker/search_test.go"
      provides: "Tests covering fuzzy match, tag filter, empty query, edge cases"
      min_lines: 60
  key_links:
    - from: "internal/picker/search.go"
      to: "internal/store/workflow.go"
      via: "WorkflowSource wraps []store.Workflow"
      pattern: "store\\.Workflow"
    - from: "internal/picker/search.go"
      to: "sahilm/fuzzy"
      via: "fuzzy.FindFrom with Source interface"
      pattern: "fuzzy\\.FindFrom"
---

<objective>
Install Phase 2 dependencies (Charm stack, sahilm/fuzzy, atotto/clipboard) and implement the search/filter logic via TDD.

Purpose: The search layer is the foundation for the picker — fuzzy matching across workflow fields with tag pre-filtering. TDD ensures correct matching behavior before building the TUI on top.
Output: `internal/picker/search.go` with tested Search, ParseQuery, and WorkflowSource.
</objective>

<execution_context>
@~/.config/opencode/agents/gsd-executor.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/store/workflow.go
@internal/store/store.go
@go.mod
</context>

<feature>
  <name>Fuzzy Search with Tag Filter</name>
  <files>internal/picker/search.go, internal/picker/search_test.go</files>
  <behavior>
    ParseQuery("@docker deploy") → tagFilter="docker", fuzzyQuery="deploy"
    ParseQuery("deploy") → tagFilter="", fuzzyQuery="deploy"
    ParseQuery("@docker") → tagFilter="docker", fuzzyQuery=""
    ParseQuery("") → tagFilter="", fuzzyQuery=""

    Search("deploy", "", workflows) → fuzzy matches sorted by score
    Search("", "docker", workflows) → all workflows tagged "docker"
    Search("dep", "docker", workflows) → fuzzy "dep" within docker-tagged workflows
    Search("", "", workflows) → all workflows in original order
    Search("nonexistent", "", workflows) → empty slice

    WorkflowSource.String(i) → "name description tag1 tag2 command" (concatenated searchable text including command content per SRCH-01)
    WorkflowSource.Len() → len(workflows)

    Search("docker build", "", workflows) → matches workflow whose command contains "docker build" (SRCH-01: search by command content)
  </behavior>
  <implementation>
    1. Run `go get` for all Phase 2 dependencies first (see task 1)
    2. RED: Write tests for ParseQuery (4 cases), Search (6 cases including command content search), WorkflowSource (2 cases)
    3. GREEN: Implement ParseQuery (split on @prefix + first space), WorkflowSource (Source interface for sahilm/fuzzy), Search (tag pre-filter → empty query bypass → fuzzy.FindFrom)
    4. REFACTOR: Clean up if needed

    Implementation details from RESEARCH.md:
    - ParseQuery: if strings.HasPrefix(raw, "@"), split on first space. parts[0][1:] is tag, parts[1] is query.
    - WorkflowSource: implements sahilm/fuzzy Source interface (String(i) string, Len() int). String concatenates Name + " " + Description + " " + strings.Join(Tags, " ") + " " + w.Command. The Command field MUST be included to satisfy SRCH-01 (search by command content).
    - Search: (1) tag pre-filter with case-insensitive tag match, (2) if query empty, return synthetic matches for all filtered workflows, (3) else call fuzzy.FindFrom(query, source).
    - filterByTag: iterate workflows, check if any tag matches (case-insensitive).
    - Pitfall 4: sahilm/fuzzy returns 0 results on empty query — bypass with synthetic matches.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Install Phase 2 dependencies</name>
  <files>go.mod, go.sum</files>
  <action>
    Run the following go get commands to install all Phase 2 dependencies:
    ```
    go get github.com/charmbracelet/bubbletea
    go get github.com/charmbracelet/bubbles
    go get github.com/charmbracelet/lipgloss
    go get github.com/sahilm/fuzzy
    go get github.com/atotto/clipboard
    ```
    Then run `go mod tidy` to clean up.
    Verify all five packages appear in go.mod requires section.
  </action>
  <verify>
    `grep -c 'charmbracelet\|sahilm\|atotto' go.mod` returns 5.
    `go build ./...` succeeds.
  </verify>
  <done>go.mod contains bubbletea, bubbles, lipgloss, sahilm/fuzzy, atotto/clipboard. Project compiles.</done>
</task>

<task type="auto">
  <name>Task 2: TDD — Search/filter logic</name>
  <files>internal/picker/search.go, internal/picker/search_test.go</files>
  <action>
    Follow RED → GREEN → REFACTOR cycle.

    **RED:** Create `internal/picker/search_test.go` with tests:
    1. TestParseQuery — 4 cases: "@docker deploy" → ("docker","deploy"); "deploy" → ("","deploy"); "@docker" → ("docker",""); "" → ("","")
    2. TestSearch_FuzzyMatch — create 3 workflows, search "deploy" → matches workflow with "deploy" in name/desc
    3. TestSearch_TagFilter — create workflows with different tags, search "" with tagFilter "docker" → only docker-tagged
    4. TestSearch_TagFilterPlusFuzzy — search "dep" with tagFilter "docker" → narrows to docker tag, then fuzzy matches
    5. TestSearch_EmptyQuery — search "" with no tag → returns all workflows
    6. TestSearch_NoMatch — search "zzzzz" → returns empty slice
    7. TestSearch_CommandContent — create workflow with command "docker build -t myimage .", search "docker build" → matches it (SRCH-01: command content search)
    8. TestWorkflowSource — verify String(i) concatenates name+desc+tags+command, Len() returns count

    Run tests — they must FAIL (package doesn't exist yet).

    **GREEN:** Create `internal/picker/search.go`:
    - package picker
    - import store, sahilm/fuzzy, strings
    - ParseQuery(raw string) (tagFilter, fuzzyQuery string)
    - type WorkflowSource []store.Workflow with String(i) and Len()
    - Search(query, tagFilter string, workflows []store.Workflow) []fuzzy.Match
    - filterByTag(workflows []store.Workflow, tag string) []store.Workflow (unexported)

    Run tests — they must PASS.

    **REFACTOR:** Only if obvious cleanup needed. Run tests again.
  </action>
  <verify>
    `go test ./internal/picker/ -v` — all tests pass.
    `go test ./... -race` — all tests pass with race detector.
  </verify>
  <done>ParseQuery correctly splits @tag prefix. Search returns fuzzy matches filtered by tag, including matches by command content (SRCH-01). Empty query returns all. WorkflowSource implements sahilm/fuzzy Source interface with command field included. All 8+ test cases pass.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles successfully with all new dependencies
2. `go test ./internal/picker/ -v` — all search tests pass
3. `go test ./... -race` — all tests pass (including Phase 1 tests)
4. `grep 'sahilm/fuzzy' go.mod` confirms fuzzy library installed
</verification>

<success_criteria>
- sahilm/fuzzy, bubbletea, bubbles, lipgloss, atotto/clipboard in go.mod
- ParseQuery handles @tag prefix extraction with 4 test cases
- Search function handles fuzzy, tag filter, empty query, and no-match cases
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-quick-picker-shell-integration/02-01-SUMMARY.md`
</output>
