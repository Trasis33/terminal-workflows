---
phase: 09-execute-in-manage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/manage/execute_dialog.go
  - internal/manage/manage.go
  - cmd/wf/manage.go
autonomous: true
requirements: [EXEC-01, EXEC-02, EXEC-03, EXEC-04]

must_haves:
  truths:
    - "Execute dialog renders param fill inputs for a workflow with parameters"
    - "Execute dialog renders action menu with Copy/Paste-to-prompt/Cancel after param fill completes"
    - "Zero-param workflows skip param fill and show action menu immediately"
    - "Manage TUI can return a completed command string to the calling cobra command"
  artifacts:
    - path: "internal/manage/execute_dialog.go"
      provides: "ExecuteDialogModel with param fill + action menu phases"
      min_lines: 250
    - path: "internal/manage/manage.go"
      provides: "Run function returning (string, error) for paste-to-prompt"
      exports: ["New", "Run"]
    - path: "cmd/wf/manage.go"
      provides: "Cobra command printing returned command to stdout"
  key_links:
    - from: "internal/manage/execute_dialog.go"
      to: "internal/template"
      via: "template.ExtractParams and template.Render"
      pattern: "template\\.ExtractParams|template\\.Render"
    - from: "internal/manage/execute_dialog.go"
      to: "internal/manage/dialog.go"
      via: "dialogResultMsg for returning results to root model"
      pattern: "dialogResultMsg"
    - from: "internal/manage/manage.go"
      to: "cmd/wf/manage.go"
      via: "Run returns (string, error), cobra prints non-empty string to stdout"
      pattern: "manage\\.Run"
---

<objective>
Create the execute dialog model for param fill + action menu inside the manage TUI, and update the manage entry point to support returning a completed command for paste-to-prompt.

Purpose: This is the core building block for EXEC-01 through EXEC-04 — the dialog that lets users fill parameters and choose what to do with the result, plus the return path for paste-to-prompt.
Output: `execute_dialog.go` with full ExecuteDialogModel, updated `manage.go` and `cmd/wf/manage.go` for the paste-to-prompt path.
</objective>

<execution_context>
@/Users/fredriklanga/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/fredriklanga/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-execute-in-manage/09-CONTEXT.md

@internal/manage/model.go
@internal/manage/dialog.go
@internal/manage/manage.go
@internal/manage/theme.go
@internal/manage/styles.go
@internal/manage/ai_actions.go
@internal/picker/paramfill.go
@internal/template/parser.go
@internal/template/renderer.go
@internal/store/workflow.go
@cmd/wf/manage.go
@cmd/wf/pick.go

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From internal/store/workflow.go:
```go
type Workflow struct {
    Name        string   `yaml:"name"`
    Command     string   `yaml:"command"`
    Description string   `yaml:"description"`
    Tags        []string `yaml:"tags,omitempty"`
    Args        []Arg    `yaml:"args,omitempty"`
}
type Arg struct {
    Name        string   `yaml:"name"`
    Default     string   `yaml:"default,omitempty"`
    Type        string   `yaml:"type,omitempty"`        // "text", "enum", "dynamic"
    Options     []string `yaml:"options,omitempty"`
    DynamicCmd  string   `yaml:"dynamic_cmd,omitempty"`
}
```

From internal/template/parser.go:
```go
type ParamType int
const (
    ParamText    ParamType = iota
    ParamEnum
    ParamDynamic
)
type Param struct {
    Name       string
    Type       ParamType
    Default    string
    Options    []string
    DynamicCmd string
}
func ExtractParams(command string) []Param
```

From internal/template/renderer.go:
```go
func Render(command string, values map[string]string) string
```

From internal/manage/dialog.go:
```go
type dialogType int
const (
    dialogDeleteConfirm dialogType = iota  // 0
    dialogFolderCreate                      // 1
    dialogFolderRename                      // 2
    dialogFolderDelete                      // 3
    dialogMoveWorkflow                      // 4
)
type dialogResultMsg struct {
    dtype     dialogType
    confirmed bool
    data      map[string]string
}
type DialogModel struct { ... }
```

From internal/manage/ai_actions.go:
```go
const dialogAIGenerate dialogType = 10  // separate value space
```

From internal/manage/model.go:
```go
type Model struct {
    dialog *DialogModel  // nil = no dialog active
    // ...
}
func (m Model) renderOverlay(_ string, dialog string) string  // centers dialog
```

From internal/manage/theme.go:
```go
type themeStyles struct {
    DialogBox   lipgloss.Style  // width 50, padding 1,2, border with primary color
    DialogTitle lipgloss.Style
    Dim         lipgloss.Style
    Selected    lipgloss.Style
    Highlight   lipgloss.Style
    Hint        lipgloss.Style
}
```

From internal/manage/manage.go:
```go
func New(s store.Store, workflows []store.Workflow, theme Theme, configDir string) Model
func Run(s store.Store) error  // currently returns only error
```

From cmd/wf/pick.go (paste-to-prompt pattern):
```go
// The picker writes result to stdout, shell integration captures it
fmt.Fprintln(os.Stdout, fm.Result)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExecuteDialogModel in execute_dialog.go</name>
  <files>internal/manage/execute_dialog.go</files>
  <action>
Create `internal/manage/execute_dialog.go` with the full execute dialog model. This is a NEW dialog type that does NOT use the existing `DialogModel` — it has its own model struct because it has complex multi-phase state (param fill + action menu) that doesn't fit the simple DialogModel pattern.

**Constants and types:**

```go
const dialogExecute dialogType = 11  // after dialogAIGenerate = 10

// executePhase tracks the dialog's internal state machine
type executePhase int
const (
    phaseParamFill  executePhase = iota  // filling parameters
    phaseActionMenu                       // choosing what to do with result
)

// executeAction identifies the user's chosen action
type executeAction int
const (
    actionCopy         executeAction = iota  // copy to clipboard
    actionPasteToPrompt                      // exit manage, paste to shell
    actionCancel                             // dismiss dialog
)
```

**ExecuteDialogModel struct:**

```go
type ExecuteDialogModel struct {
    workflow     store.Workflow
    phase        executePhase

    // Param fill state (parallel arrays, same pattern as picker/paramfill.go)
    params            []template.Param
    paramInputs       []textinput.Model
    paramTypes        []template.ParamType
    paramOptions      [][]string
    paramOptionCursor []int
    paramLoading      []bool
    paramFailed       []bool
    focusedParam      int

    // Action menu state
    renderedCommand  string       // final rendered command
    actionCursor     int          // 0=copy, 1=paste, 2=cancel
    actions          []string     // display labels

    // Layout
    width   int
    theme   Theme
}
```

**Constructor — `NewExecuteDialog(wf store.Workflow, width int, theme Theme) ExecuteDialogModel`:**

- Call `template.ExtractParams(wf.Command)` to get params
- Merge stored Arg defaults into params (same logic as picker's `initParamFill`): iterate params, for each with empty Default, find matching wf.Args entry by name and copy its Default
- If `len(params) == 0`: set `phase = phaseActionMenu`, render command immediately with `template.Render(wf.Command, nil)`, set `renderedCommand`
- If params exist: set `phase = phaseParamFill`, initialize parallel arrays:
  - For each param, create `textinput.Model` with placeholder = param name, char limit 256
  - For `ParamEnum`: set `paramOptions[i]` from `param.Options`, find default index, set `paramOptionCursor[i]`, set input value to `options[defaultIdx]`
  - For `ParamDynamic`: set `paramLoading[i] = true`, set placeholder = "Loading..."
  - For `ParamText`: if default exists, set input value, use dim text style (lipgloss.NewStyle().Foreground(lipgloss.Color("242")))
  - Focus first input (index 0)
- Set `actions = []string{"Copy to clipboard", "Paste to prompt", "Cancel"}`
- Set `width` from parameter (~60-70% terminal width, caller computes)

**Init() method:**
- Return `textinput.Blink` if in phaseParamFill and has text inputs
- Return nil otherwise

**InitCmds() method** (separate from Init, called by root model after dialog is set):
- For each ParamDynamic param, return a `tea.Cmd` that runs `executeDynamic(idx, dynamicCmd)` — reuse the `executeDynamic` function from picker package. Actually, since it's in the picker package and not exported in the right way, DUPLICATE the function locally:

```go
func executeDialogDynamic(paramIndex int, command string) executeDialogDynamicMsg {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    cmd := exec.CommandContext(ctx, "sh", "-c", command)
    output, err := cmd.Output()
    if err != nil {
        return executeDialogDynamicMsg{paramIndex: paramIndex, err: err}
    }
    var options []string
    scanner := bufio.NewScanner(bytes.NewReader(output))
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if line != "" {
            options = append(options, line)
        }
    }
    if len(options) == 0 {
        return executeDialogDynamicMsg{paramIndex: paramIndex, err: fmt.Errorf("no output")}
    }
    return executeDialogDynamicMsg{paramIndex: paramIndex, options: options}
}
```

Define `executeDialogDynamicMsg` as a local message type:
```go
type executeDialogDynamicMsg struct {
    paramIndex int
    options    []string
    err        error
}
```

**Update(msg tea.Msg) method:**
Handle both `tea.KeyMsg` and `executeDialogDynamicMsg`:

For `executeDialogDynamicMsg`:
- If error: set `paramFailed[msg.paramIndex] = true`, `paramLoading[msg.paramIndex] = false`, update placeholder to param name
- If success: set options, set `paramOptions[msg.paramIndex]`, `paramLoading[msg.paramIndex] = false`, `paramTypes[msg.paramIndex] = template.ParamEnum` (so isListParam works), set input value to first option

For `tea.KeyMsg` route by phase:

**phaseParamFill key handling** (adapted from picker's `updateParamFill`):
- `esc`: return `dialogResultMsg{dtype: dialogExecute, confirmed: false}` — cancels entire dialog
- `tab`: blur current, focus next param (wrap around)
- `shift+tab`: blur current, focus prev param (wrap around)
- `up`: if enum/dynamic with options, cycle option cursor up; else pass to textinput
- `down`: if enum/dynamic with options, cycle option cursor down; else pass to textinput
- `enter`: if on last param OR all params filled → transition to phaseActionMenu: compute `renderedCommand` via `template.Render`, set `phase = phaseActionMenu`, `actionCursor = 0`; else advance to next param (same as tab)
- default: if enum/dynamic param, ignore; else forward to textinput, update text style for defaults

**phaseActionMenu key handling:**
- `esc`: return `dialogResultMsg{dtype: dialogExecute, confirmed: false}` — cancel
- `up`, `k`: move `actionCursor` up (min 0)
- `down`, `j`: move `actionCursor` down (max 2)
- `enter`: based on actionCursor:
  - 0 (copy): return `dialogResultMsg{dtype: dialogExecute, confirmed: true, data: map[string]string{"action": "copy", "command": renderedCommand}}`
  - 1 (paste): return `dialogResultMsg{dtype: dialogExecute, confirmed: true, data: map[string]string{"action": "paste", "command": renderedCommand}}`
  - 2 (cancel): return `dialogResultMsg{dtype: dialogExecute, confirmed: false}`

**Helper — `isListParam(i int) bool`:**
Same logic as picker: returns true for ParamEnum, or ParamDynamic that loaded successfully.

**Helper — `liveRender() string`:**
Build values map from paramInputs, call `template.Render(workflow.Command, values)`.

**View() method:**
Renders the dialog content (NOT the overlay — overlay is handled by model.go's renderOverlay).

Use a WIDER dialog box than the standard DialogBox style — create a local style based on theme:
```go
dialogStyle := lipgloss.NewStyle().
    Border(lipgloss.RoundedBorder()).
    BorderForeground(lipgloss.Color(d.theme.Colors.Primary)).
    Padding(1, 2).
    Width(d.width)  // ~60-70% terminal width, passed in
```

**phaseParamFill view:**
```
┌─ Execute: {workflow.Name} ──────────────────┐
│                                              │
│  ❯ command preview (live-rendered)           │
│                                              │
│  param1: [input__________]                   │
│  param2: [selected_option] ▼                 │
│  param3: Loading... (dynamic_cmd)            │
│                                              │
│  tab next  ↑↓ select  enter submit  esc cancel│
└──────────────────────────────────────────────┘
```

- Title: `s.DialogTitle.Render("Execute: " + d.workflow.Name)`
- Command preview: `s.Dim.Render(d.liveRender())` — rendered command with current values
- Param rows: same rendering as picker's `viewParamFill` but adapted:
  - Focused param: `❯` prefix + primary color label + input/option view
  - Unfocused param: `  ` prefix + dim label + input/option view
  - Loading dynamic: dim "Loading..."
  - Failed dynamic: text input + dim "(command failed, type manually)"
  - Enum with options: highlight selected + option list when focused (max 5 visible, scrollable)
- Hints: `s.Dim.Render("[tab] next  [↑↓] select  [enter] submit  [esc] cancel")`

**phaseActionMenu view:**
```
┌─ Execute: {workflow.Name} ──────────────────┐
│                                              │
│  {rendered command}                          │
│                                              │
│  ❯ Copy to clipboard                        │
│    Paste to prompt                           │
│    Cancel                                    │
│                                              │
│  ↑↓ select  enter confirm  esc cancel        │
└──────────────────────────────────────────────┘
```

- Title: same as above
- Command display: rendered command in highlight style (not dim — this is the final result)
- Action list: cursor `❯` prefix + selected style for focused, plain for unfocused
- Hints: `s.Dim.Render("[↑↓] select  [enter] confirm  [esc] cancel")`

Wrap all content in the dialog style.
  </action>
  <verify>
    <automated>cd /Users/fredriklanga/Documents/Projects2026/terminal-workflows && go build ./internal/manage/</automated>
  </verify>
  <done>ExecuteDialogModel compiles, has NewExecuteDialog constructor, Update handles both phases (param fill + action menu), View renders both phases, supports all 3 param types (text, enum, dynamic), returns dialogResultMsg with action and command data</done>
</task>

<task type="auto">
  <name>Task 2: Update manage entry point for paste-to-prompt return path</name>
  <files>internal/manage/manage.go, cmd/wf/manage.go</files>
  <action>
**Update `internal/manage/manage.go`:**

Change `Run` signature from `func Run(s store.Store) error` to `func Run(s store.Store) (string, error)`.

The returned string is the completed command for paste-to-prompt (empty string means no command to paste).

Add a `result` field to the `Model` struct in model.go:
```go
// In Model struct, add:
result string  // completed command for paste-to-prompt exit
```

Update `Run()`:
```go
func Run(s store.Store) (string, error) {
    workflows, err := s.List()
    if err != nil {
        return "", err
    }
    cfgDir := config.ConfigDir()
    theme, err := LoadTheme(cfgDir)
    if err != nil {
        theme = DefaultTheme()
    }
    m := New(s, workflows, theme, cfgDir)
    p := tea.NewProgram(m, tea.WithAltScreen())
    final, err := p.Run()
    if err != nil {
        return "", err
    }
    fm, ok := final.(Model)
    if !ok {
        return "", nil
    }
    return fm.result, nil
}
```

**Update `cmd/wf/manage.go`:**

Change the cobra RunE to handle the returned command:
```go
RunE: func(cmd *cobra.Command, args []string) error {
    result, err := manage.Run(getMultiStore())
    if err != nil {
        return err
    }
    // If a command was produced (paste-to-prompt), print to stdout
    // for shell integration capture — same pattern as wf pick.
    if result != "" {
        fmt.Fprintln(os.Stdout, result)
    }
    return nil
},
```

Add `"fmt"` and `"os"` imports to `cmd/wf/manage.go`.

**Also add the `result` field to Model struct in model.go** (this file is listed in plan 02's files_modified too, but the field addition is needed here for the return path to work):

In `internal/manage/model.go`, add to Model struct:
```go
result string // completed command for paste-to-prompt exit
```

This field will be SET by plan 02's dialog result handling, but must EXIST here for Run() to read it.
  </action>
  <verify>
    <automated>cd /Users/fredriklanga/Documents/Projects2026/terminal-workflows && go build ./...</automated>
  </verify>
  <done>manage.Run returns (string, error), cobra command prints non-empty result to stdout, Model struct has result field, entire project compiles with go build ./...</done>
</task>

</tasks>

<verification>
- `go build ./...` passes — entire project compiles including updated manage.go signature
- `go test ./internal/manage/...` passes — existing tests still work with updated Run signature (tests don't call Run directly, they use New)
- ExecuteDialogModel can be instantiated with a test workflow
</verification>

<success_criteria>
- execute_dialog.go exists with ExecuteDialogModel supporting both param fill and action menu phases
- manage.Run returns (string, error) instead of just error
- cmd/wf/manage.go prints non-empty result to stdout
- All three param types (text, enum, dynamic) are handled in the execute dialog
- Zero-param workflows skip straight to action menu
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/09-execute-in-manage/09-01-SUMMARY.md`
</output>
