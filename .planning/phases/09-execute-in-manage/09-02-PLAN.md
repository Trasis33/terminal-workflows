---
phase: 09-execute-in-manage
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - internal/manage/model.go
  - internal/manage/browse.go
  - internal/manage/model_test.go
autonomous: false
requirements: [EXEC-01, EXEC-02, EXEC-03, EXEC-04]

must_haves:
  truths:
    - "User pressing Enter on a workflow in browse opens the execute dialog"
    - "Copy action copies command to clipboard, closes dialog, shows flash message, user stays in browse"
    - "Paste-to-prompt action exits manage and the completed command appears on shell prompt"
    - "Cancel action closes dialog, browse state is fully preserved"
    - "Browse hints bar shows Enter hint for the execute feature"
  artifacts:
    - path: "internal/manage/model.go"
      provides: "Execute dialog lifecycle, result handling, flash message, paste-to-prompt exit"
      contains: "dialogExecute"
    - path: "internal/manage/browse.go"
      provides: "Enter key trigger, flash message rendering, updated hints"
      contains: "enter"
    - path: "internal/manage/model_test.go"
      provides: "Tests for execute dialog trigger, action results, flash message"
      min_lines: 500
  key_links:
    - from: "internal/manage/browse.go"
      to: "internal/manage/model.go"
      via: "showExecuteDialogMsg triggers dialog creation"
      pattern: "showExecuteDialogMsg"
    - from: "internal/manage/model.go"
      to: "internal/manage/execute_dialog.go"
      via: "NewExecuteDialog called on showExecuteDialogMsg"
      pattern: "NewExecuteDialog"
    - from: "internal/manage/model.go"
      to: "clipboard"
      via: "clipboard.WriteAll on copy action"
      pattern: "clipboard\\.WriteAll"
---

<objective>
Wire the execute dialog into the manage TUI — Enter key trigger in browse, dialog lifecycle in root model, clipboard copy with flash message, paste-to-prompt exit, and comprehensive tests.

Purpose: Complete the execute-in-manage feature by connecting the ExecuteDialogModel (from plan 01) to the browse view and root model, handling all user-facing flows.
Output: Updated model.go, browse.go, model_test.go with full integration and tests.
</objective>

<execution_context>
@/Users/fredriklanga/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/fredriklanga/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-execute-in-manage/09-CONTEXT.md
@.planning/phases/09-execute-in-manage/09-01-SUMMARY.md

@internal/manage/model.go
@internal/manage/browse.go
@internal/manage/dialog.go
@internal/manage/execute_dialog.go
@internal/manage/model_test.go
@internal/manage/manage.go
@internal/manage/keys.go

<interfaces>
<!-- From plan 01 outputs -->

From internal/manage/execute_dialog.go (created in plan 01):
```go
const dialogExecute dialogType = 11

type ExecuteDialogModel struct {
    workflow     store.Workflow
    phase        executePhase
    // ... param fill state, action menu state
    width        int
    theme        Theme
}

func NewExecuteDialog(wf store.Workflow, width int, theme Theme) ExecuteDialogModel
func (d ExecuteDialogModel) Init() tea.Cmd
func (d ExecuteDialogModel) InitCmds() []tea.Cmd
func (d ExecuteDialogModel) Update(msg tea.Msg) (ExecuteDialogModel, tea.Cmd)
func (d ExecuteDialogModel) View() string

// Dialog result data keys:
// data["action"] = "copy" | "paste"
// data["command"] = rendered command string
```

From internal/manage/model.go (updated in plan 01):
```go
type Model struct {
    result string  // completed command for paste-to-prompt exit (added in plan 01)
    // ...existing fields...
}
```

From internal/manage/dialog.go:
```go
type dialogResultMsg struct {
    dtype     dialogType
    confirmed bool
    data      map[string]string
}
```

From internal/manage/browse.go:
```go
type BrowseModel struct {
    filtered  []store.Workflow
    cursor    int
    // ...
}
func (b BrowseModel) renderHints(s themeStyles) string
```

From cmd/wf/pick.go (clipboard pattern):
```go
import "github.com/atotto/clipboard"
clipboard.WriteAll(result)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire execute dialog into browse and root model</name>
  <files>internal/manage/model.go, internal/manage/browse.go</files>
  <action>
**New message types in model.go:**

```go
// showExecuteDialogMsg triggers the execute dialog for a workflow.
type showExecuteDialogMsg struct{ workflow store.Workflow }

// clearFlashMsg clears the flash message after a timeout.
type clearFlashMsg struct{}
```

**Update Model struct in model.go:**

Add execute dialog and flash message fields:
```go
// In Model struct, add alongside existing fields:
execDialog *ExecuteDialogModel  // execute dialog (separate from *DialogModel)
flashMsg   string               // transient flash message (e.g. "Copied!")
```

**Update Model.Update in model.go:**

1. Handle `tea.KeyMsg` — when `execDialog` is active, route to it BEFORE the regular dialog check:
```go
case tea.KeyMsg:
    // Execute dialog gets priority if active.
    if m.execDialog != nil {
        return m.updateExecDialog(msg)
    }
    // Dialog gets priority if active.
    if m.dialog != nil {
        return m.updateDialog(msg)
    }
    // ... rest unchanged
```

2. Handle `executeDialogDynamicMsg` — route to exec dialog:
```go
case executeDialogDynamicMsg:
    if m.execDialog != nil {
        dlg := *m.execDialog
        var cmd tea.Cmd
        dlg, cmd = dlg.Update(msg)
        m.execDialog = &dlg
        return m, cmd
    }
    return m, nil
```

3. Handle `showExecuteDialogMsg`:
```go
case showExecuteDialogMsg:
    dialogWidth := m.width * 65 / 100  // ~65% terminal width
    if dialogWidth < 50 {
        dialogWidth = 50
    }
    if dialogWidth > 90 {
        dialogWidth = 90
    }
    dlg := NewExecuteDialog(msg.workflow, dialogWidth, m.theme)
    m.execDialog = &dlg
    cmds := []tea.Cmd{dlg.Init()}
    cmds = append(cmds, dlg.InitCmds()...)
    return m, tea.Batch(cmds...)
```

4. Handle `clearFlashMsg`:
```go
case clearFlashMsg:
    m.flashMsg = ""
    return m, nil
```

5. Handle `dialogResultMsg` — add `dialogExecute` case in `handleDialogResult`:
```go
case dialogExecute:
    m.execDialog = nil  // dismiss execute dialog
    if !msg.confirmed {
        return m, nil  // cancel — return to browse
    }
    action := msg.data["action"]
    command := msg.data["command"]
    switch action {
    case "copy":
        if err := clipboard.WriteAll(command); err != nil {
            m.browse.aiError = "Clipboard error: " + err.Error()
            return m, nil
        }
        m.flashMsg = "Copied!"
        return m, tea.Tick(1500*time.Millisecond, func(time.Time) tea.Msg {
            return clearFlashMsg{}
        })
    case "paste":
        m.result = command
        return m, tea.Quit
    }
    return m, nil
```

IMPORTANT: The `dialogExecute` case must also handle clearing `execDialog` instead of `dialog`:
- In the main `handleDialogResult` method, add a check at the top: if `msg.dtype == dialogExecute`, handle it specially (clear `execDialog` not `dialog`). The existing `m.dialog = nil` at the top of `handleDialogResult` should NOT run for execute dialogs. Restructure:
```go
func (m Model) handleDialogResult(msg dialogResultMsg) (tea.Model, tea.Cmd) {
    if msg.dtype == dialogExecute {
        m.execDialog = nil  // clear execute dialog, not regular dialog
        if !msg.confirmed {
            return m, nil
        }
        // ... handle copy/paste actions as above
    }

    m.dialog = nil  // dismiss regular dialog
    // ... rest of existing handler unchanged
}
```

6. Add `updateExecDialog` method:
```go
func (m Model) updateExecDialog(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
    dlg := *m.execDialog
    var cmd tea.Cmd
    dlg, cmd = dlg.Update(msg)
    m.execDialog = &dlg
    return m, cmd
}
```

**Update Model.View in model.go:**

When `execDialog` is active, render it as an overlay (same as regular dialog):
```go
if m.execDialog != nil {
    return m.renderOverlay(base, m.execDialog.View())
}
```

This goes BEFORE the existing `if m.dialog != nil` check.

**Add imports to model.go:**
```go
import (
    "time"
    "github.com/atotto/clipboard"
)
```

**Update browse.go — Enter key in updateListFocus:**

Add an `"enter"` case in `updateListFocus`:
```go
case "enter":
    if len(b.filtered) > 0 {
        wf := b.filtered[b.cursor]
        return b, func() tea.Msg { return showExecuteDialogMsg{workflow: wf} }
    }
    return b, nil
```

Place this case BEFORE the existing key handling (or in the switch alongside other keys). It goes with the other action keys (e, d, m).

**Update browse.go — Flash message in renderHints:**

Show flash message when set (takes priority over normal hints but NOT over AI error):
```go
func (b BrowseModel) renderHints(s themeStyles) string {
    // Show transient AI error first.
    if b.aiError != "" {
        errStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Bold(true)
        return errStyle.Render("  ⚠ " + b.aiError)
    }

    // Show flash message if set.
    if b.flashMsg != "" {
        flashStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("49")).Bold(true)
        return flashStyle.Render("  ✓ " + b.flashMsg)
    }

    // ... rest unchanged
}
```

Add `flashMsg string` field to `BrowseModel` struct.

Update model.go to propagate flash to browse when setting it:
```go
// In the copy action handler:
m.flashMsg = "Copied!"
m.browse.flashMsg = "Copied!"
```

And in clearFlashMsg handler:
```go
case clearFlashMsg:
    m.flashMsg = ""
    m.browse.flashMsg = ""
    return m, nil
```

**Update browse.go — hints bar:**

Change the list focus hints to include Enter:
```go
hints = "enter run  n new  e edit  d delete  m move  G generate  A autofill  / search  J/K preview scroll  tab folders/tags  ←/h sidebar  S settings  q quit"
```

"enter run" is placed first since it's the primary action.

**Add `Execute` keybinding to keys.go** (optional but consistent — the Enter binding already exists but isn't explicitly used in list focus):
No change needed to keys.go since the Enter key is already defined. The `case "enter"` in the switch handles it directly.
  </action>
  <verify>
    <automated>cd /Users/fredriklanga/Documents/Projects2026/terminal-workflows && go build ./... && go test ./internal/manage/... -count=1</automated>
  </verify>
  <done>Enter key on a workflow in browse opens execute dialog, copy action writes to clipboard + flash message + stays in manage, paste action sets result + quits, cancel dismisses dialog, browse state preserved, hints bar shows "enter run"</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for execute dialog and integration</name>
  <files>internal/manage/model_test.go</files>
  <action>
Add comprehensive tests to `internal/manage/model_test.go` for the execute dialog feature. Follow existing test patterns in the file (mockStore, DefaultTheme, tea.KeyMsg construction).

**Tests to add:**

1. **TestExecuteDialogCreation** — Create an ExecuteDialogModel with a workflow that has 2 text params. Verify:
   - `phase` starts as `phaseParamFill`
   - `len(params)` == 2
   - `len(paramInputs)` == 2
   - First input is focused

2. **TestExecuteDialogZeroParams** — Create dialog with workflow `{Command: "ls -la"}` (no params). Verify:
   - `phase` is `phaseActionMenu` immediately
   - `renderedCommand` == "ls -la"
   - View contains "ls -la" and "Copy to clipboard"

3. **TestExecuteDialogParamFillToActionMenu** — Create dialog with `{Command: "echo {{msg}}"}`:
   - Type "hello" into param (simulate key msgs to textinput)
   - Press enter → should transition to phaseActionMenu
   - Verify `renderedCommand` == "echo hello"
   - View contains "Copy to clipboard", "Paste to prompt", "Cancel"

4. **TestExecuteDialogEscCancelsFromParamFill** — Create dialog with params:
   - Press esc
   - Verify returned cmd produces `dialogResultMsg{dtype: dialogExecute, confirmed: false}`

5. **TestExecuteDialogEscCancelsFromActionMenu** — Create zero-param dialog:
   - Press esc
   - Verify returned cmd produces `dialogResultMsg{dtype: dialogExecute, confirmed: false}`

6. **TestExecuteDialogCopyAction** — Create zero-param dialog, press enter on "Copy to clipboard":
   - Verify cmd produces `dialogResultMsg{confirmed: true, data: {"action": "copy", "command": "..."}}`

7. **TestExecuteDialogPasteAction** — Create zero-param dialog:
   - Press down (move to "Paste to prompt")
   - Press enter
   - Verify cmd produces `dialogResultMsg{confirmed: true, data: {"action": "paste", "command": "..."}}`

8. **TestEnterKeyOpensExecuteDialog** — Full integration via root Model:
   - Create Model with a workflow
   - Set dimensions
   - Send `tea.KeyMsg{Type: tea.KeyEnter}` while in browse with list focus
   - Verify the returned cmd produces `showExecuteDialogMsg`

9. **TestExecuteDialogRendersOverlay** — Create Model with execDialog set:
   - Set dimensions
   - Call View()
   - Verify output contains "Execute:" and the workflow name

10. **TestDialogExecuteCopyResultHandling** — Send `dialogResultMsg{dtype: dialogExecute, confirmed: true, data: {"action": "copy", "command": "ls"}}` to root Model:
    - Verify `execDialog` is nil (dismissed)
    - Verify `flashMsg` is "Copied!" (or browse.flashMsg)
    - Note: clipboard.WriteAll may fail in test env — that's OK, test the message handling

11. **TestDialogExecutePasteResultHandling** — Send paste dialogResultMsg to root Model:
    - Verify `result` field is set to the command
    - Verify returned cmd is `tea.Quit`

12. **TestDialogExecuteCancelResultHandling** — Send cancel (confirmed: false) dialogResultMsg:
    - Verify `execDialog` is nil
    - Verify `result` is empty

13. **TestFlashMessageClearsOnTimeout** — Send clearFlashMsg to Model:
    - Verify `flashMsg` is empty
    - Verify `browse.flashMsg` is empty

14. **TestBrowseHintsShowEnterRun** — Render browse view, verify hints contain "enter run"

15. **TestExecuteDialogEnumParam** — Create dialog with workflow containing `{{env|dev|staging|prod}}`:
    - Verify param type is enum
    - Verify options are [dev, staging, prod]
    - Send down key, verify option cursor moves
    - Press enter, verify transitions to action menu with correct value

16. **TestExecuteDialogWithDefaults** — Create dialog with `{{name:world}}`:
    - Verify input value is pre-filled with "world"
    - Press enter without changing, verify renderedCommand uses "world"

**Test construction patterns (follow existing file):**
```go
// Key msg construction:
tea.KeyMsg{Type: tea.KeyEnter}
tea.KeyMsg{Type: tea.KeyEscape}
tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}}
tea.KeyMsg{Type: tea.KeyDown}

// Model setup:
s := &mockStore{workflows: []store.Workflow{...}}
m := New(s, s.workflows, DefaultTheme(), "/tmp/test")
m.width = 100
m.height = 30
m.browse.SetDimensions(100, 30)
```
  </action>
  <verify>
    <automated>cd /Users/fredriklanga/Documents/Projects2026/terminal-workflows && go test ./internal/manage/... -count=1 -v</automated>
  </verify>
  <done>All new execute dialog tests pass, existing tests still pass, test coverage includes: zero-param shortcut, param fill navigation, action menu selection, copy/paste/cancel flows, Enter key trigger, overlay rendering, flash message lifecycle, enum params, default values</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify execute dialog end-to-end</name>
  <files>N/A</files>
  <action>
Human verifies the complete execute-in-manage feature works end-to-end.

What was built: Complete execute-in-manage feature — Enter triggers param fill dialog on any workflow, fill parameters inline, copy to clipboard or paste to shell prompt.

Steps to verify:
1. Run `go run ./cmd/wf/ manage` to launch manage TUI
2. Navigate to a workflow WITH parameters (e.g. one using {{param}} syntax)
3. Press Enter — verify execute dialog appears as overlay with param inputs
4. Fill parameters using tab/enter navigation — verify live command preview updates
5. After last param, verify action menu appears with 3 options
6. Select "Copy to clipboard" — verify dialog closes, flash "Copied!" appears, clipboard has the command
7. Press Enter again on a workflow WITHOUT parameters — verify action menu appears immediately (no param fill)
8. Select "Paste to prompt" — verify manage exits
9. Verify the command appeared on your shell prompt (requires shell integration: `eval "$(wf init zsh)"`)
10. Re-launch manage, press Enter, then press Esc — verify dialog closes, browse state is preserved

Resume signal: Type "approved" or describe issues
  </action>
  <verify>Human approval</verify>
  <done>User confirms all execute dialog flows work correctly</done>
</task>

</tasks>

<verification>
- `go build ./...` passes
- `go test ./internal/manage/... -count=1` passes with all new tests
- `go vet ./...` passes
- Enter key opens execute dialog in browse
- Copy to clipboard works with flash message
- Paste-to-prompt exits and prints to stdout
- Cancel preserves browse state
</verification>

<success_criteria>
- Enter on a workflow in browse view opens the execute dialog overlay
- Param fill works for text, enum, and dynamic params (same UX as picker)
- Zero-param workflows skip to action menu
- Copy writes to clipboard, shows flash, stays in manage
- Paste exits manage and prints command to stdout for shell capture
- Esc cancels at any point, browse state preserved
- Hints bar shows "enter run"
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-execute-in-manage/09-02-SUMMARY.md`
</output>
